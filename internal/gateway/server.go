package gateway

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"log/slog"
	"net/http"
	"time"

	"github.com/SebastienMelki/causality/internal/nats"
	"github.com/SebastienMelki/causality/internal/observability"
	pb "github.com/SebastienMelki/causality/pkg/proto/causality/v1"
)

// ServerOpts holds optional dependencies for the HTTP gateway server.
type ServerOpts struct {
	// AuthMiddleware is HTTP middleware that validates API keys. If nil,
	// no authentication is enforced.
	AuthMiddleware func(http.Handler) http.Handler

	// MetricsHandler serves Prometheus metrics. If nil, no /metrics endpoint
	// is registered.
	MetricsHandler http.Handler

	// Metrics provides OTel metric instruments for HTTP middleware.
	// If nil, HTTP metrics are not recorded.
	Metrics *observability.Metrics

	// Dedup provides deduplication checking. If nil, dedup is disabled.
	Dedup DedupChecker

	// AdminRouteRegistrar registers admin API routes (e.g., key management)
	// onto the mux. If nil, no admin routes are mounted.
	AdminRouteRegistrar func(mux *http.ServeMux)
}

// Server is the HTTP gateway server.
type Server struct {
	httpServer   *http.Server
	config       Config
	eventService *EventService
	natsClient   *nats.Client
	logger       *slog.Logger
}

// NewServer creates a new HTTP gateway server with the given options.
func NewServer(cfg Config, natsClient *nats.Client, publisher *nats.Publisher, logger *slog.Logger, opts *ServerOpts) (*Server, error) {
	if logger == nil {
		logger = slog.Default()
	}
	if opts == nil {
		opts = &ServerOpts{}
	}

	eventService := NewEventService(publisher, opts.Dedup, cfg.MaxBatchEvents, logger)

	server := &Server{
		config:       cfg,
		eventService: eventService,
		natsClient:   natsClient,
		logger:       logger.With("component", "http-server"),
	}

	mux := http.NewServeMux()

	// Register sebuf-generated HTTP handlers for EventService
	if err := pb.RegisterEventServiceServer(eventService, pb.WithMux(mux)); err != nil {
		return nil, fmt.Errorf("failed to register event service: %w", err)
	}

	// Health endpoints (not generated by sebuf)
	mux.HandleFunc("GET /health", server.handleHealth)
	mux.HandleFunc("GET /ready", server.handleReady)

	// Prometheus metrics endpoint
	if opts.MetricsHandler != nil {
		mux.Handle("GET /metrics", opts.MetricsHandler)
	}

	// Admin routes (API key management)
	if opts.AdminRouteRegistrar != nil {
		opts.AdminRouteRegistrar(mux)
	}

	// Build middleware chain.
	// Order (outermost first): RequestID -> Logging -> Recovery -> HTTPMetrics ->
	// CORS -> BodySizeLimit -> Auth -> PerKeyRateLimit -> ContentType
	middlewares := []Middleware{
		RequestID,
		Logging(server.logger),
		Recovery(server.logger),
	}

	// OTel HTTP metrics (if available)
	if opts.Metrics != nil {
		middlewares = append(middlewares, observability.HTTPMetrics(opts.Metrics))
	}

	middlewares = append(middlewares,
		CORS(server.config.CORS),
		BodySizeLimit(server.config.MaxBodySize),
	)

	// Auth middleware (if available)
	if opts.AuthMiddleware != nil {
		middlewares = append(middlewares, opts.AuthMiddleware)
	}

	// Per-key rate limiting (after auth, so app_id is in context)
	middlewares = append(middlewares, PerKeyRateLimit(server.config.RateLimit))

	// Content type
	middlewares = append(middlewares, ContentType)

	handler := Chain(mux, middlewares...)

	server.httpServer = &http.Server{
		Addr:           cfg.Addr,
		Handler:        handler,
		ReadTimeout:    cfg.ReadTimeout,
		WriteTimeout:   cfg.WriteTimeout,
		IdleTimeout:    cfg.IdleTimeout,
		MaxHeaderBytes: cfg.MaxHeaderBytes,
	}

	return server, nil
}

// Start starts the HTTP server.
func (s *Server) Start() error {
	s.logger.Info("starting HTTP server", "addr", s.config.Addr)
	if err := s.httpServer.ListenAndServe(); err != nil && !errors.Is(err, http.ErrServerClosed) {
		return fmt.Errorf("server error: %w", err)
	}
	return nil
}

// Shutdown gracefully shuts down the server.
func (s *Server) Shutdown(ctx context.Context) error {
	s.logger.Info("shutting down HTTP server")
	ctx, cancel := context.WithTimeout(ctx, s.config.ShutdownTimeout)
	defer cancel()
	return s.httpServer.Shutdown(ctx)
}

// handleHealth handles GET /health.
func (s *Server) handleHealth(w http.ResponseWriter, _ *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	if err := json.NewEncoder(w).Encode(map[string]string{
		"status":    "healthy",
		"timestamp": time.Now().UTC().Format(time.RFC3339),
	}); err != nil {
		s.logger.Error("failed to encode health response", "error", err)
	}
}

// handleReady handles GET /ready.
func (s *Server) handleReady(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	if err := s.natsClient.HealthCheck(r.Context()); err != nil {
		w.WriteHeader(http.StatusServiceUnavailable)
		if encErr := json.NewEncoder(w).Encode(map[string]string{
			"status": "not_ready",
			"error":  err.Error(),
		}); encErr != nil {
			s.logger.Error("failed to encode not_ready response", "error", encErr)
		}
		return
	}
	if err := json.NewEncoder(w).Encode(map[string]string{
		"status":    "ready",
		"timestamp": time.Now().UTC().Format(time.RFC3339),
	}); err != nil {
		s.logger.Error("failed to encode ready response", "error", err)
	}
}
