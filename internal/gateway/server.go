package gateway

import (
	"context"
	"database/sql"
	"encoding/json"
	"errors"
	"fmt"
	"log/slog"
	"net/http"
	"time"

	"github.com/SebastienMelki/causality/internal/admin"
	"github.com/SebastienMelki/causality/internal/nats"
	pb "github.com/SebastienMelki/causality/pkg/proto/causality/v1"
)

// Server is the HTTP gateway server.
type Server struct {
	httpServer   *http.Server
	config       Config
	eventService *EventService
	natsClient   *nats.Client
	logger       *slog.Logger
}

// NewServer creates a new HTTP gateway server.
// After buf generate, replace manual routing with sebuf-generated handlers:
//
//	api.RegisterEventServiceServer(eventService, api.WithMux(mux))
func NewServer(cfg Config, natsClient *nats.Client, publisher *nats.Publisher, db *sql.DB, logger *slog.Logger) (*Server, error) {
	if logger == nil {
		logger = slog.Default()
	}

	eventService := NewEventService(publisher, logger)

	server := &Server{
		config:       cfg,
		eventService: eventService,
		natsClient:   natsClient,
		logger:       logger.With("component", "http-server"),
	}

	mux := http.NewServeMux()

	// Register sebuf-generated HTTP handlers for EventService
	if err := pb.RegisterEventServiceServer(eventService, pb.WithMux(mux)); err != nil {
		return nil, fmt.Errorf("failed to register event service: %w", err)
	}

	// Health endpoints (not generated by sebuf)
	mux.HandleFunc("GET /health", server.handleHealth)
	mux.HandleFunc("GET /ready", server.handleReady)

	// Register admin routes if enabled
	if cfg.Admin.Enabled {
		trinoCfg := admin.TrinoConfig{
			Host:    cfg.Trino.Host,
			Port:    cfg.Trino.Port,
			Catalog: cfg.Trino.Catalog,
			Schema:  cfg.Trino.Schema,
			User:    cfg.Trino.User,
		}
		adminHandler, err := admin.NewHandler(db, trinoCfg, logger)
		if err != nil {
			return nil, fmt.Errorf("failed to create admin handler: %w", err)
		}
		adminHandler.RegisterRoutes(mux)
		logger.Info("admin UI enabled", "base_path", cfg.Admin.BasePath)
	}

	// Apply middleware
	handler := Chain(mux,
		RequestID,
		Logging(server.logger),
		Recovery(server.logger),
		CORS(server.config.CORS),
		RateLimit(server.config.RateLimit),
		ContentType,
	)

	server.httpServer = &http.Server{
		Addr:           cfg.Addr,
		Handler:        handler,
		ReadTimeout:    cfg.ReadTimeout,
		WriteTimeout:   cfg.WriteTimeout,
		IdleTimeout:    cfg.IdleTimeout,
		MaxHeaderBytes: cfg.MaxHeaderBytes,
	}

	return server, nil
}

// Start starts the HTTP server.
func (s *Server) Start() error {
	s.logger.Info("starting HTTP server", "addr", s.config.Addr)
	if err := s.httpServer.ListenAndServe(); err != nil && !errors.Is(err, http.ErrServerClosed) {
		return fmt.Errorf("server error: %w", err)
	}
	return nil
}

// Shutdown gracefully shuts down the server.
func (s *Server) Shutdown(ctx context.Context) error {
	s.logger.Info("shutting down HTTP server")
	ctx, cancel := context.WithTimeout(ctx, s.config.ShutdownTimeout)
	defer cancel()
	return s.httpServer.Shutdown(ctx)
}

// handleHealth handles GET /health.
func (s *Server) handleHealth(w http.ResponseWriter, _ *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	if err := json.NewEncoder(w).Encode(map[string]string{
		"status":    "healthy",
		"timestamp": time.Now().UTC().Format(time.RFC3339),
	}); err != nil {
		s.logger.Error("failed to encode health response", "error", err)
	}
}

// handleReady handles GET /ready.
func (s *Server) handleReady(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	if err := s.natsClient.HealthCheck(r.Context()); err != nil {
		w.WriteHeader(http.StatusServiceUnavailable)
		if encErr := json.NewEncoder(w).Encode(map[string]string{
			"status": "not_ready",
			"error":  err.Error(),
		}); encErr != nil {
			s.logger.Error("failed to encode not_ready response", "error", encErr)
		}
		return
	}
	if err := json.NewEncoder(w).Encode(map[string]string{
		"status":    "ready",
		"timestamp": time.Now().UTC().Format(time.RFC3339),
	}); err != nil {
		s.logger.Error("failed to encode ready response", "error", err)
	}
}
