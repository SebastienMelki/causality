---
phase: 02-gomobile-sdk
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - sdk/mobile/internal/session/tracker.go
  - sdk/mobile/internal/session/events.go
  - sdk/mobile/internal/session/tracker_test.go
autonomous: true

must_haves:
  truths:
    - "New session starts after timeout period in background"
    - "Session ID is consistent within a session"
    - "session_start event fires on new session"
    - "session_end event fires with duration when session ends"
  artifacts:
    - path: "sdk/mobile/internal/session/tracker.go"
      provides: "Hybrid session tracking (timeout + lifecycle)"
      exports: ["NewTracker", "RecordActivity", "AppDidEnterBackground", "AppWillEnterForeground", "CurrentSessionID", "SetEnabled"]
    - path: "sdk/mobile/internal/session/events.go"
      provides: "Session event generation"
      exports: ["SessionStartEvent", "SessionEndEvent"]
  key_links:
    - from: "sdk/mobile/internal/session/tracker.go"
      to: "github.com/google/uuid"
      via: "Session ID generation"
      pattern: "uuid.New"
---

<objective>
Implement hybrid session tracking that combines timeout-based and lifecycle-based session detection.

Purpose: Sessions are fundamental to analytics. A session represents a period of user engagement. The hybrid approach (timeout + app lifecycle) is industry standard, combining accuracy (lifecycle events) with robustness (timeout fallback).

Output: `sdk/mobile/internal/session/` package with session tracker and event generation.
</objective>

<execution_context>
@/Users/sebastienmelki/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sebastienmelki/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-gomobile-sdk/02-CONTEXT.md
@.planning/phases/02-gomobile-sdk/02-RESEARCH.md
@.planning/phases/02-gomobile-sdk/02-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement session tracker with hybrid detection</name>
  <files>
    sdk/mobile/internal/session/tracker.go
  </files>
  <action>
**sdk/mobile/internal/session/tracker.go:**

Tracker struct:
- mu sync.RWMutex (protect concurrent access)
- sessionID string (current session, empty if none)
- sessionStart time.Time
- lastActivity time.Time
- backgroundedAt time.Time
- timeout time.Duration (configurable, default 30s)
- enabled bool (can be disabled via config)
- onSessionStart func(sessionID string) (callback for event generation)
- onSessionEnd func(sessionID string, durationMs int64) (callback for event generation)

NewTracker(timeout time.Duration, onStart, onEnd callbacks) *Tracker:
- Initialize with timeout
- enabled = true by default
- No session active initially

RecordActivity() string:
- RLock fast path: if session valid and not expired, update lastActivity, return sessionID
- If expired or no session: acquire Lock, double-check, end old session if exists, start new
- Return current session ID
- Thread-safe for concurrent Track() calls

AppDidEnterBackground():
- Lock
- Record backgroundedAt = time.Now()
- Do NOT end session yet (user might return quickly)
- Unlock

AppWillEnterForeground():
- Lock
- If session exists AND time.Since(backgroundedAt) > timeout:
  - End old session (call onSessionEnd with duration)
  - Clear sessionID
- RecordActivity will start new session on next Track()
- Unlock

endSession() (internal):
- Calculate duration from sessionStart to lastActivity
- Call onSessionEnd callback with sessionID and durationMs
- Clear sessionID

startSession() (internal):
- Generate new UUID
- Set sessionStart = now, lastActivity = now
- Call onSessionStart callback with new sessionID
- Return new sessionID

CurrentSessionID() string:
- RLock, return sessionID, RUnlock
- Returns empty string if no active session

SetEnabled(enabled bool):
- Lock
- If disabling and session active, end it
- Set enabled flag
- Unlock

GetSessionDuration() int64:
- If session active, return time.Since(sessionStart).Milliseconds()
- Else return 0

Session expiry check: `time.Since(lastActivity) > timeout`

Use industry standard 30s default timeout (per Braze/Amplitude research).
  </action>
  <verify>
    - `go build ./sdk/mobile/internal/session/` compiles
    - No data races: `go build -race ./sdk/mobile/internal/session/`
  </verify>
  <done>
    - Tracker handles timeout-based session expiry
    - Background/foreground lifecycle integration works
    - Thread-safe for concurrent access
    - Callbacks fire for session start/end
  </done>
</task>

<task type="auto">
  <name>Task 2: Create session events and unit tests</name>
  <files>
    sdk/mobile/internal/session/events.go
    sdk/mobile/internal/session/tracker_test.go
  </files>
  <action>
**sdk/mobile/internal/session/events.go:**

SessionStartEvent(sessionID string) map[string]interface{}:
- Returns event properties for session_start
- { "session_id": sessionID, "event_type": "session_start" }

SessionEndEvent(sessionID string, durationMs int64) map[string]interface{}:
- Returns event properties for session_end
- { "session_id": sessionID, "event_type": "session_end", "duration_ms": durationMs }

These are helper functions - actual event creation happens in the main SDK layer.

**sdk/mobile/internal/session/tracker_test.go:**

TestNewTracker_DefaultsEnabled:
- Verify enabled = true
- Verify no session initially

TestRecordActivity_StartsNewSession:
- Record activity
- Verify session ID is not empty
- Verify onSessionStart callback called

TestRecordActivity_SameSessionWithinTimeout:
- Record activity
- Wait < timeout
- Record activity again
- Verify same session ID

TestRecordActivity_NewSessionAfterTimeout:
- Record activity, note session ID
- Simulate time passing > timeout (use test clock or short timeout)
- Record activity
- Verify different session ID
- Verify onSessionEnd called with duration
- Verify onSessionStart called

TestAppLifecycle_BackgroundForegroundQuick:
- Record activity
- AppDidEnterBackground
- Wait < timeout
- AppWillEnterForeground
- Verify same session continues

TestAppLifecycle_BackgroundForegroundLong:
- Record activity, note session ID
- AppDidEnterBackground
- Simulate time > timeout
- AppWillEnterForeground
- Verify session ended
- Record activity
- Verify new session ID

TestSetEnabled_DisablingEndsSession:
- Record activity
- SetEnabled(false)
- Verify onSessionEnd called
- Verify CurrentSessionID returns empty

TestConcurrentAccess:
- Spawn 100 goroutines calling RecordActivity
- Verify no data races (use -race flag)
- Verify callbacks not called multiple times erroneously

Use time manipulation for timeout tests:
- Option A: Short timeout (10ms) for tests
- Option B: Inject time.Now function for testing
  </action>
  <verify>
    - `go test ./sdk/mobile/internal/session/... -v` passes
    - `go test ./sdk/mobile/internal/session/... -race` passes (no data races)
    - `go test ./sdk/mobile/internal/session/... -cover` shows >= 85% coverage
  </verify>
  <done>
    - Session events have correct structure
    - All session lifecycle scenarios tested
    - Thread-safety verified with -race
    - Coverage >= 85%
  </done>
</task>

</tasks>

<verification>
- Build: `go build ./sdk/mobile/internal/session/`
- Tests: `go test ./sdk/mobile/internal/session/... -v -race`
- Coverage: `go test ./sdk/mobile/internal/session/... -cover`
</verification>

<success_criteria>
- Session tracker uses hybrid timeout + lifecycle approach
- New session after 30s (default) in background
- session_start fires when new session begins
- session_end fires with duration when session ends
- Thread-safe for concurrent Track() calls
- Tests pass with >= 85% coverage, no data races
</success_criteria>

<output>
After completion, create `.planning/phases/02-gomobile-sdk/02-03-SUMMARY.md`
</output>
