---
phase: 02-gomobile-sdk
plan: 07
type: execute
wave: 5
depends_on: ["02-06"]
files_modified:
  - sdk/ios/Package.swift
  - sdk/ios/Sources/Causality/Causality.swift
  - sdk/ios/Sources/Causality/Config.swift
  - sdk/ios/Sources/Causality/Event.swift
  - sdk/ios/Sources/Causality/Internal/Bridge.swift
  - sdk/ios/Sources/Causality/Internal/Platform.swift
  - sdk/ios/Tests/CausalityTests/CausalityTests.swift
autonomous: true

must_haves:
  truths:
    - "Swift wrapper provides idiomatic async/await API"
    - "Codable structs for type-safe configuration"
    - "Track calls are non-blocking"
    - "SDK handles JSON serialization transparently"
  artifacts:
    - path: "sdk/ios/Package.swift"
      provides: "SPM manifest with binaryTarget"
      contains: "binaryTarget"
    - path: "sdk/ios/Sources/Causality/Causality.swift"
      provides: "Main SDK class with async/await"
      exports: ["Causality", "initialize", "track", "flush"]
    - path: "sdk/ios/Sources/Causality/Config.swift"
      provides: "Codable configuration struct"
      contains: "struct Config: Codable"
    - path: "sdk/ios/Sources/Causality/Event.swift"
      provides: "Type-safe event builders"
      exports: ["Event", "EventBuilder"]
  key_links:
    - from: "sdk/ios/Sources/Causality/Causality.swift"
      to: "sdk/ios/Sources/Causality/Internal/Bridge.swift"
      via: "JSON bridge to Go core"
      pattern: "Bridge"
---

<objective>
Create idiomatic Swift wrapper with async/await API, Codable types, and SPM distribution.

Purpose: The Swift wrapper hides the JSON bridge complexity and provides a native iOS developer experience. Using async/await (Swift 5.5+), Codable, and Swift Package Manager makes integration feel native.

Output: `sdk/ios/` SPM package ready for distribution.
</objective>

<execution_context>
@/Users/sebastienmelki/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sebastienmelki/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-gomobile-sdk/02-CONTEXT.md
@.planning/phases/02-gomobile-sdk/02-RESEARCH.md
@.planning/phases/02-gomobile-sdk/02-06-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SPM package structure and configuration types</name>
  <files>
    sdk/ios/Package.swift
    sdk/ios/Sources/Causality/Config.swift
    sdk/ios/Sources/Causality/Event.swift
    sdk/ios/Sources/Causality/Internal/Bridge.swift
    sdk/ios/Sources/Causality/Internal/Platform.swift
  </files>
  <action>
**sdk/ios/Package.swift:**
```swift
// swift-tools-version:5.9

import PackageDescription

let package = Package(
    name: "Causality",
    platforms: [
        .iOS(.v14),
        .macOS(.v11)
    ],
    products: [
        .library(
            name: "Causality",
            targets: ["CausalitySwift"]
        )
    ],
    targets: [
        // Binary target for Go core (local path for development)
        .binaryTarget(
            name: "CausalityCore",
            path: "../../build/mobile/Causality.xcframework"
        ),
        // Swift wrapper
        .target(
            name: "CausalitySwift",
            dependencies: ["CausalityCore"],
            path: "Sources/Causality"
        ),
        .testTarget(
            name: "CausalityTests",
            dependencies: ["CausalitySwift"],
            path: "Tests/CausalityTests"
        )
    ]
)
```

Note: For release, replace local path with URL + checksum.

**sdk/ios/Sources/Causality/Config.swift:**
```swift
import Foundation

/// Configuration for the Causality SDK
public struct Config: Codable {
    /// API key for authentication (required)
    public var apiKey: String

    /// Server endpoint URL (required)
    public var endpoint: String

    /// Application identifier (required)
    public var appId: String

    /// Maximum events per batch (optional, default: 30)
    public var batchSize: Int?

    /// Flush interval in milliseconds (optional, default: 30000)
    public var flushIntervalMs: Int?

    /// Maximum queue size (optional, default: 10000)
    public var maxQueueSize: Int?

    /// Session timeout in milliseconds (optional, default: 30000)
    public var sessionTimeoutMs: Int?

    /// Enable debug logging (optional, default: false)
    public var debugMode: Bool?

    /// Enable automatic session tracking (optional, default: true)
    public var enableSessionTracking: Bool?

    /// Use persistent device ID across reinstalls (optional, default: false)
    public var persistentDeviceId: Bool?

    public init(
        apiKey: String,
        endpoint: String,
        appId: String,
        batchSize: Int? = nil,
        flushIntervalMs: Int? = nil,
        maxQueueSize: Int? = nil,
        sessionTimeoutMs: Int? = nil,
        debugMode: Bool? = nil,
        enableSessionTracking: Bool? = nil,
        persistentDeviceId: Bool? = nil
    ) {
        self.apiKey = apiKey
        self.endpoint = endpoint
        self.appId = appId
        self.batchSize = batchSize
        self.flushIntervalMs = flushIntervalMs
        self.maxQueueSize = maxQueueSize
        self.sessionTimeoutMs = sessionTimeoutMs
        self.debugMode = debugMode
        self.enableSessionTracking = enableSessionTracking
        self.persistentDeviceId = persistentDeviceId
    }

    private enum CodingKeys: String, CodingKey {
        case apiKey = "api_key"
        case endpoint
        case appId = "app_id"
        case batchSize = "batch_size"
        case flushIntervalMs = "flush_interval_ms"
        case maxQueueSize = "max_queue_size"
        case sessionTimeoutMs = "session_timeout_ms"
        case debugMode = "debug_mode"
        case enableSessionTracking = "enable_session_tracking"
        case persistentDeviceId = "persistent_device_id"
    }
}
```

**sdk/ios/Sources/Causality/Event.swift:**
```swift
import Foundation

/// An analytics event
public struct Event: Codable {
    /// Event type (e.g., "button_tap", "screen_view")
    public var type: String

    /// Event properties as key-value pairs
    public var properties: [String: AnyCodable]?

    /// Timestamp (ISO8601, auto-populated if not provided)
    public var timestamp: String?

    public init(type: String, properties: [String: AnyCodable]? = nil, timestamp: String? = nil) {
        self.type = type
        self.properties = properties
        self.timestamp = timestamp
    }
}

/// Event builder for fluent API
public class EventBuilder {
    private var type: String
    private var properties: [String: AnyCodable] = [:]

    public init(type: String) {
        self.type = type
    }

    @discardableResult
    public func property(_ key: String, _ value: String) -> EventBuilder {
        properties[key] = AnyCodable(value)
        return self
    }

    @discardableResult
    public func property(_ key: String, _ value: Int) -> EventBuilder {
        properties[key] = AnyCodable(value)
        return self
    }

    @discardableResult
    public func property(_ key: String, _ value: Double) -> EventBuilder {
        properties[key] = AnyCodable(value)
        return self
    }

    @discardableResult
    public func property(_ key: String, _ value: Bool) -> EventBuilder {
        properties[key] = AnyCodable(value)
        return self
    }

    public func build() -> Event {
        Event(type: type, properties: properties.isEmpty ? nil : properties)
    }
}

/// Type-erased Codable wrapper for property values
public struct AnyCodable: Codable {
    public let value: Any

    public init(_ value: Any) {
        self.value = value
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let string = try? container.decode(String.self) {
            value = string
        } else if let int = try? container.decode(Int.self) {
            value = int
        } else if let double = try? container.decode(Double.self) {
            value = double
        } else if let bool = try? container.decode(Bool.self) {
            value = bool
        } else {
            throw DecodingError.typeMismatch(AnyCodable.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Unsupported type"))
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch value {
        case let string as String:
            try container.encode(string)
        case let int as Int:
            try container.encode(int)
        case let double as Double:
            try container.encode(double)
        case let bool as Bool:
            try container.encode(bool)
        default:
            throw EncodingError.invalidValue(value, EncodingError.Context(codingPath: encoder.codingPath, debugDescription: "Unsupported type"))
        }
    }
}
```

**sdk/ios/Sources/Causality/Internal/Bridge.swift:**
```swift
import Foundation
import CausalityCore

/// Internal bridge to Go core via JSON
enum Bridge {
    static func initSDK(config: Config) throws {
        let jsonData = try JSONEncoder().encode(config)
        guard let jsonString = String(data: jsonData, encoding: .utf8) else {
            throw CausalityError.encoding("Failed to encode config")
        }
        let result = MobileInit(jsonString)
        if !result.isEmpty {
            throw CausalityError.initialization(result)
        }
    }

    static func track(event: Event) throws {
        let jsonData = try JSONEncoder().encode(event)
        guard let jsonString = String(data: jsonData, encoding: .utf8) else {
            throw CausalityError.encoding("Failed to encode event")
        }
        let result = MobileTrack(jsonString)
        if !result.isEmpty {
            throw CausalityError.tracking(result)
        }
    }

    static func setUser(userId: String, traits: [String: AnyCodable]?, aliases: [String]?) throws {
        struct UserPayload: Codable {
            let userId: String
            let traits: [String: AnyCodable]?
            let aliases: [String]?

            enum CodingKeys: String, CodingKey {
                case userId = "user_id"
                case traits
                case aliases
            }
        }

        let payload = UserPayload(userId: userId, traits: traits, aliases: aliases)
        let jsonData = try JSONEncoder().encode(payload)
        guard let jsonString = String(data: jsonData, encoding: .utf8) else {
            throw CausalityError.encoding("Failed to encode user")
        }
        let result = MobileSetUser(jsonString)
        if !result.isEmpty {
            throw CausalityError.identification(result)
        }
    }

    static func reset() throws {
        let result = MobileReset()
        if !result.isEmpty {
            throw CausalityError.reset(result)
        }
    }

    static func resetAll() throws {
        let result = MobileResetAll()
        if !result.isEmpty {
            throw CausalityError.reset(result)
        }
    }

    static func flush() throws {
        let result = MobileFlush()
        if !result.isEmpty {
            throw CausalityError.flush(result)
        }
    }

    static func getDeviceId() -> String {
        MobileGetDeviceId()
    }

    static func isInitialized() -> Bool {
        MobileIsInitialized()
    }

    static func appDidEnterBackground() {
        _ = MobileAppDidEnterBackground()
    }

    static func appWillEnterForeground() {
        _ = MobileAppWillEnterForeground()
    }
}
```

**sdk/ios/Sources/Causality/Internal/Platform.swift:**
```swift
import Foundation
#if canImport(UIKit)
import UIKit
#endif

/// Collects iOS platform context
enum Platform {
    static func collectContext() -> (
        platform: String,
        osVersion: String,
        model: String,
        manufacturer: String,
        appVersion: String,
        buildNumber: String,
        screenWidth: Int,
        screenHeight: Int,
        locale: String,
        timezone: String
    ) {
        let device = UIDevice.current
        let bundle = Bundle.main
        let screen = UIScreen.main

        return (
            platform: "ios",
            osVersion: device.systemVersion,
            model: device.model,
            manufacturer: "Apple",
            appVersion: bundle.infoDictionary?["CFBundleShortVersionString"] as? String ?? "unknown",
            buildNumber: bundle.infoDictionary?["CFBundleVersion"] as? String ?? "unknown",
            screenWidth: Int(screen.bounds.width * screen.scale),
            screenHeight: Int(screen.bounds.height * screen.scale),
            locale: Locale.current.identifier,
            timezone: TimeZone.current.identifier
        )
    }

    static func setPlatformContext() {
        let ctx = collectContext()
        MobileSetPlatformContext(
            ctx.platform,
            ctx.osVersion,
            ctx.model,
            ctx.manufacturer,
            ctx.appVersion,
            ctx.buildNumber,
            ctx.screenWidth,
            ctx.screenHeight,
            ctx.locale,
            ctx.timezone
        )
    }
}
```
  </action>
  <verify>
    - Directory structure exists: `ls -la sdk/ios/Sources/Causality/`
    - Package.swift syntax valid (when .xcframework exists)
  </verify>
  <done>
    - SPM package structure created
    - Config uses Codable with snake_case JSON keys
    - Event supports typed properties via AnyCodable
    - Bridge handles JSON serialization to Go core
    - Platform collects iOS device context
  </done>
</task>

<task type="auto">
  <name>Task 2: Create main SDK class with async/await and tests</name>
  <files>
    sdk/ios/Sources/Causality/Causality.swift
    sdk/ios/Sources/Causality/Errors.swift
    sdk/ios/Tests/CausalityTests/CausalityTests.swift
  </files>
  <action>
**sdk/ios/Sources/Causality/Errors.swift:**
```swift
import Foundation

/// Errors thrown by the Causality SDK
public enum CausalityError: Error, LocalizedError {
    case notInitialized
    case encoding(String)
    case initialization(String)
    case tracking(String)
    case identification(String)
    case reset(String)
    case flush(String)

    public var errorDescription: String? {
        switch self {
        case .notInitialized:
            return "Causality SDK is not initialized. Call initialize() first."
        case .encoding(let message):
            return "Encoding error: \(message)"
        case .initialization(let message):
            return "Initialization error: \(message)"
        case .tracking(let message):
            return "Tracking error: \(message)"
        case .identification(let message):
            return "Identification error: \(message)"
        case .reset(let message):
            return "Reset error: \(message)"
        case .flush(let message):
            return "Flush error: \(message)"
        }
    }
}
```

**sdk/ios/Sources/Causality/Causality.swift:**
```swift
import Foundation
import CausalityCore
#if canImport(UIKit)
import UIKit
#endif

/// Main entry point for the Causality analytics SDK
@MainActor
public final class Causality {
    /// Shared singleton instance
    public static let shared = Causality()

    private var isInitialized = false

    private init() {
        // Register for lifecycle notifications
        #if canImport(UIKit)
        NotificationCenter.default.addObserver(
            self,
            selector: #selector(appDidEnterBackground),
            name: UIApplication.didEnterBackgroundNotification,
            object: nil
        )
        NotificationCenter.default.addObserver(
            self,
            selector: #selector(appWillEnterForeground),
            name: UIApplication.willEnterForegroundNotification,
            object: nil
        )
        #endif
    }

    /// Initialize the SDK with configuration
    /// - Parameter config: SDK configuration
    /// - Throws: CausalityError if initialization fails
    public func initialize(config: Config) throws {
        // Set platform context first
        Platform.setPlatformContext()

        // Initialize Go core
        try Bridge.initSDK(config: config)
        isInitialized = true
    }

    /// Track an event
    /// - Parameter event: The event to track
    /// - Note: This method is non-blocking. Events are queued for batch sending.
    public func track(_ event: Event) {
        guard isInitialized else {
            #if DEBUG
            print("[Causality] Warning: SDK not initialized, event dropped")
            #endif
            return
        }

        Task.detached(priority: .utility) {
            do {
                try Bridge.track(event: event)
            } catch {
                #if DEBUG
                print("[Causality] Track error: \(error)")
                #endif
            }
        }
    }

    /// Track an event using a builder
    /// - Parameter type: Event type
    /// - Returns: EventBuilder for fluent property addition
    public func track(type: String) -> EventBuilder {
        EventBuilder(type: type)
    }

    /// Set user identity
    /// - Parameters:
    ///   - userId: Unique user identifier
    ///   - traits: Optional user properties
    ///   - aliases: Optional alias identifiers
    public func identify(userId: String, traits: [String: AnyCodable]? = nil, aliases: [String]? = nil) throws {
        guard isInitialized else {
            throw CausalityError.notInitialized
        }
        try Bridge.setUser(userId: userId, traits: traits, aliases: aliases)
    }

    /// Clear user identity (soft reset - keeps device ID)
    public func reset() throws {
        guard isInitialized else {
            throw CausalityError.notInitialized
        }
        try Bridge.reset()
    }

    /// Full reset - clears user identity and regenerates device ID
    public func resetAll() throws {
        guard isInitialized else {
            throw CausalityError.notInitialized
        }
        try Bridge.resetAll()
    }

    /// Force flush all queued events
    public func flush() async throws {
        guard isInitialized else {
            throw CausalityError.notInitialized
        }

        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Void, Error>) in
            DispatchQueue.global(qos: .utility).async {
                do {
                    try Bridge.flush()
                    continuation.resume()
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Get the device identifier
    /// - Returns: Device ID, or empty string if not initialized
    public var deviceId: String {
        Bridge.getDeviceId()
    }

    /// Check if SDK is initialized
    public var initialized: Bool {
        Bridge.isInitialized()
    }

    // MARK: - Lifecycle

    @objc private func appDidEnterBackground() {
        Bridge.appDidEnterBackground()
    }

    @objc private func appWillEnterForeground() {
        Bridge.appWillEnterForeground()
    }

    deinit {
        NotificationCenter.default.removeObserver(self)
    }
}

// MARK: - Convenience extensions

public extension Causality {
    /// Track a screen view
    func trackScreenView(name: String, properties: [String: AnyCodable]? = nil) {
        var props = properties ?? [:]
        props["screen_name"] = AnyCodable(name)
        track(Event(type: "screen_view", properties: props))
    }

    /// Track a button tap
    func trackButtonTap(name: String, properties: [String: AnyCodable]? = nil) {
        var props = properties ?? [:]
        props["button_name"] = AnyCodable(name)
        track(Event(type: "button_tap", properties: props))
    }
}
```

**sdk/ios/Tests/CausalityTests/CausalityTests.swift:**
```swift
import XCTest
@testable import CausalitySwift

final class CausalityTests: XCTestCase {

    func testConfigEncoding() throws {
        let config = Config(
            apiKey: "test-key",
            endpoint: "https://api.example.com",
            appId: "test-app",
            batchSize: 50,
            debugMode: true
        )

        let encoder = JSONEncoder()
        let data = try encoder.encode(config)
        let json = String(data: data, encoding: .utf8)!

        XCTAssertTrue(json.contains("\"api_key\":\"test-key\""))
        XCTAssertTrue(json.contains("\"app_id\":\"test-app\""))
        XCTAssertTrue(json.contains("\"batch_size\":50"))
    }

    func testEventBuilder() {
        let event = EventBuilder(type: "purchase")
            .property("product_id", "abc123")
            .property("price", 29.99)
            .property("quantity", 2)
            .build()

        XCTAssertEqual(event.type, "purchase")
        XCTAssertNotNil(event.properties)
        XCTAssertEqual(event.properties?["product_id"]?.value as? String, "abc123")
        XCTAssertEqual(event.properties?["price"]?.value as? Double, 29.99)
        XCTAssertEqual(event.properties?["quantity"]?.value as? Int, 2)
    }

    func testEventEncoding() throws {
        let event = Event(
            type: "test_event",
            properties: [
                "string_prop": AnyCodable("value"),
                "int_prop": AnyCodable(42),
                "bool_prop": AnyCodable(true)
            ]
        )

        let encoder = JSONEncoder()
        let data = try encoder.encode(event)
        let json = String(data: data, encoding: .utf8)!

        XCTAssertTrue(json.contains("\"type\":\"test_event\""))
    }

    func testAnyCodableRoundtrip() throws {
        let original = AnyCodable("test string")

        let encoder = JSONEncoder()
        let data = try encoder.encode(original)

        let decoder = JSONDecoder()
        let decoded = try decoder.decode(AnyCodable.self, from: data)

        XCTAssertEqual(decoded.value as? String, "test string")
    }
}
```
  </action>
  <verify>
    - All Swift files have valid syntax
    - Test file structure correct: `ls sdk/ios/Tests/CausalityTests/`
  </verify>
  <done>
    - Causality singleton with async/await flush
    - Automatic lifecycle notification handling
    - Non-blocking track() with Task.detached
    - Convenience methods for common events
    - Tests for encoding and builder
  </done>
</task>

</tasks>

<verification>
- Package structure: `ls -la sdk/ios/Sources/Causality/`
- Tests structure: `ls -la sdk/ios/Tests/`
- (Full verification requires .xcframework from gomobile build)
</verification>

<success_criteria>
- SPM package with binaryTarget for Go core
- Causality class with async/await API
- Config and Event use Codable for type safety
- EventBuilder provides fluent API
- Automatic lifecycle handling (background/foreground)
- Track is non-blocking
- Tests verify encoding and builder
</success_criteria>

<output>
After completion, create `.planning/phases/02-gomobile-sdk/02-07-SUMMARY.md`
</output>
