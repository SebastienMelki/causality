---
phase: 01-pipeline-hardening-observability-go-sdk
plan: 09
type: execute
wave: 4
depends_on: ["01-06"]
files_modified:
  - sdk/go/causality.go
  - sdk/go/config.go
  - sdk/go/transport.go
  - sdk/go/batch.go
  - sdk/go/event.go
  - sdk/go/go.mod
  - sdk/go/go.sum
autonomous: true

must_haves:
  truths:
    - "Go SDK module at github.com/SebastienMelki/causality/sdk/go"
    - "Track(event) enqueues event for async batch sending"
    - "Flush() forces send of all queued events"
    - "Close() flushes and shuts down cleanly"
    - "SDK sets idempotency_key (UUID) on each event"
    - "SDK retries failed sends with exponential backoff"
    - "SDK collects server context (hostname, Go version, SDK version)"
    - "SDK sends events via /v1/events/batch endpoint with X-API-Key header"
  artifacts:
    - path: "sdk/go/causality.go"
      provides: "Main Client struct with Track, Flush, Close"
      exports: ["Client", "New", "Track", "Flush", "Close"]
    - path: "sdk/go/config.go"
      provides: "Client configuration"
      exports: ["Config"]
    - path: "sdk/go/transport.go"
      provides: "HTTP transport with retry and backoff"
      contains: "exponentialBackoff"
    - path: "sdk/go/batch.go"
      provides: "Batching logic with size/time triggers"
      contains: "flushLoop"
    - path: "sdk/go/event.go"
      provides: "Event type definitions"
      exports: ["Event"]
    - path: "sdk/go/go.mod"
      provides: "Separate Go module"
      contains: "github.com/SebastienMelki/causality/sdk/go"
  key_links:
    - from: "sdk/go/causality.go"
      to: "sdk/go/batch.go"
      via: "Track enqueues to batch, flushLoop sends"
      pattern: "flushLoop"
    - from: "sdk/go/transport.go"
      to: "/v1/events/batch"
      via: "HTTP POST to batch endpoint with X-API-Key"
      pattern: "v1/events/batch"
    - from: "sdk/go/causality.go"
      to: "github.com/google/uuid"
      via: "generates idempotency key per event"
      pattern: "uuid\\.New"
---

<objective>
Create the Go backend SDK as a separate Go module that provides Track, Flush, and Close operations with batching, retry, and idempotency key generation.

Purpose: R1.9 requires a Go module for server-side event collection. This SDK is the first SDK and validates the API design pattern that gomobile and web SDKs will follow.
Output: `sdk/go/` directory with a complete Go module providing `causality.New(cfg)`, `client.Track(event)`, `client.Flush()`, `client.Close()`.
</objective>

<execution_context>
@/Users/sebastienmelki/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sebastienmelki/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-pipeline-hardening-observability-go-sdk/01-RESEARCH.md
@.planning/phases/01-pipeline-hardening-observability-go-sdk/01-06-SUMMARY.md
@internal/gateway/service.go
@proto/causality/events.proto
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Go SDK module with event types, config, and transport</name>
  <files>
    sdk/go/go.mod
    sdk/go/event.go
    sdk/go/config.go
    sdk/go/transport.go
  </files>
  <action>
    **Create `sdk/go/go.mod`:**
    ```
    module github.com/SebastienMelki/causality/sdk/go

    go 1.24

    require github.com/google/uuid v1.6.0
    ```
    - Run `cd sdk/go && go mod tidy` to resolve dependencies
    - The SDK has minimal dependencies: only uuid for idempotency keys. HTTP client is stdlib.
    - Do NOT depend on the main causality module or protobuf — the SDK sends JSON over HTTP.

    **Create `sdk/go/event.go`:**
    - `Event` struct (JSON-serializable):
      ```go
      type Event struct {
          AppID          string                 `json:"app_id"`
          EventType      string                 `json:"event_type"`
          IdempotencyKey string                 `json:"idempotency_key,omitempty"`
          TimestampMs    int64                  `json:"timestamp_ms,omitempty"`
          DeviceID       string                 `json:"device_id,omitempty"`
          UserID         string                 `json:"user_id,omitempty"`
          SessionID      string                 `json:"session_id,omitempty"`
          Properties     map[string]interface{} `json:"properties,omitempty"`
      }
      ```
    - `ServerContext` struct (auto-collected):
      ```go
      type ServerContext struct {
          Hostname   string `json:"hostname"`
          GoVersion  string `json:"go_version"`
          SDKVersion string `json:"sdk_version"`
      }
      ```
    - `const SDKVersion = "0.1.0"`
    - `collectServerContext() ServerContext` — collects `os.Hostname()`, `runtime.Version()`, SDKVersion

    **Create `sdk/go/config.go`:**
    - `Config` struct:
      ```go
      type Config struct {
          APIKey        string        // Required: API key for authentication
          Endpoint      string        // Required: server URL (e.g., "http://localhost:8080")
          AppID         string        // Required: default app_id for events
          BatchSize     int           // Default: 50
          FlushInterval time.Duration // Default: 30s
          MaxRetries    int           // Default: 3
          Timeout       time.Duration // Default: 10s (per HTTP request)
      }
      ```
    - `func (c *Config) validate() error` — checks APIKey, Endpoint, AppID are non-empty
    - `func (c *Config) withDefaults() Config` — applies defaults for zero values

    **Create `sdk/go/transport.go`:**
    - `httpTransport` struct:
      - `client *http.Client`
      - `endpoint string` (full URL: endpoint + "/v1/events/batch")
      - `apiKey string`
      - `maxRetries int`
    - `newHTTPTransport(cfg Config) *httpTransport`
    - `sendBatch(ctx context.Context, events []Event) error`:
      1. Marshal events to JSON batch request body: `{"events": [...]}`
      2. Create POST request to `endpoint + "/v1/events/batch"`
      3. Set headers: `Content-Type: application/json`, `X-API-Key: apiKey`
      4. Send request with retry:
         - On 5xx or network error: retry with exponential backoff (1s, 2s, 4s, ... up to maxRetries)
         - On 4xx: return error immediately (client error, don't retry)
         - On 200: return nil
      5. Add jitter to backoff: `backoff * (0.5 + rand.Float64())`
    - `exponentialBackoff(attempt int) time.Duration` — `min(time.Duration(1<<attempt) * time.Second, 30*time.Second)`

    **JSON Content-Type Compatibility (MUST VERIFY):**
    The SDK sends JSON, not protobuf. Before finalizing the transport, verify that the server accepts JSON:
    1. Read `internal/gateway/service.go` and check how the batch endpoint deserializes the request body
    2. If the server uses `protojson.Unmarshal` or `proto.Unmarshal`: the SDK must send protojson-formatted JSON (field names match proto field names, e.g., `snake_case`)
    3. If the server uses a custom JSON decoder or `encoding/json`: the SDK sends standard JSON
    4. If the server ONLY accepts binary protobuf (Content-Type: application/protobuf): EITHER add a JSON handler to the server gateway (preferred — add as sub-task) OR switch the SDK to use protobuf encoding (adds proto dependency)

    The preferred path is JSON with protojson-compatible field names (snake_case, matching the proto definitions). The server's protobuf handlers via `google.golang.org/protobuf/encoding/protojson` should accept this when Content-Type is `application/json`.

    Set the transport Content-Type header to `application/json` and structure the JSON body to match the protojson representation of `IngestEventBatchRequest`:
    ```json
    {
      "events": [
        {
          "app_id": "...",
          "event_type": "...",
          "idempotency_key": "...",
          "timestamp_ms": 1234567890,
          ...
        }
      ]
    }
    ```
  </action>
  <verify>
    - `cd sdk/go && go build ./...` compiles
    - `cd sdk/go && go vet ./...` passes
    - go.mod has correct module path
    - Event struct has all required fields
    - Transport has retry with exponential backoff
    **JSON compatibility verification:**
    - Read `internal/gateway/service.go` to confirm the server's deserialization method for the batch endpoint
    - Verify the SDK's JSON field names match the server's expected format (proto field names are snake_case)
    - If the server does not accept JSON, create a sub-task to add a JSON handler to the gateway, or switch SDK to protobuf encoding
    - Write a simple test in `sdk/go/transport_test.go` that marshals an Event and verifies the JSON field names match the protojson format (e.g., `"app_id"` not `"AppID"`, `"timestamp_ms"` not `"TimestampMs"`)
  </verify>
  <done>
    SDK module has event types, config with validation and defaults, and HTTP transport with retry and exponential backoff. Module is self-contained with minimal dependencies.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Go SDK client with Track, Flush, Close and batch loop</name>
  <files>
    sdk/go/causality.go
    sdk/go/batch.go
  </files>
  <action>
    **Create `sdk/go/batch.go`:**
    - `batcher` struct:
      - `events []Event`
      - `mu sync.Mutex`
      - `batchSize int`
      - `flushCh chan struct{}`
      - `transport *httpTransport`
      - `logger func(string, ...interface{})` (optional logger, can be nil)
      - `serverCtx ServerContext`
    - `newBatcher(cfg Config, transport *httpTransport) *batcher`
    - `add(event Event) bool` — adds event to batch, returns true if batch is full
    - `drain() []Event` — swaps batch and returns events (thread-safe)
    - `flushLoop(ctx context.Context, interval time.Duration, done chan struct{})`:
      - Timer-based loop: flush on interval OR on flushCh signal OR on ctx.Done
      - On trigger: drain batch, if non-empty call `transport.sendBatch(ctx, events)`
      - On send error: log error but don't crash (events are lost — this is acceptable for a server SDK where events are best-effort)
      - Close `done` channel when loop exits

    **Create `sdk/go/causality.go`:**
    - `Client` struct:
      - `config Config`
      - `batcher *batcher`
      - `serverCtx ServerContext`
      - `cancelFn context.CancelFunc`
      - `doneCh chan struct{}`
    - `New(cfg Config) (*Client, error)`:
      1. Validate config
      2. Apply defaults
      3. Collect server context
      4. Create transport
      5. Create batcher
      6. Create background context with cancel
      7. Start `batcher.flushLoop` goroutine
      8. Return client
    - `Track(event Event)`:
      1. Set `event.IdempotencyKey = uuid.New().String()` (always, even if set by caller — SDK guarantees uniqueness)
      2. Set `event.TimestampMs = time.Now().UnixMilli()` if zero
      3. Set `event.AppID = c.config.AppID` if empty
      4. Add server context to event properties (hostname, go_version, sdk_version) under `_server` key
      5. Call `c.batcher.add(event)`
      6. If batch full: signal flush
    - `Flush() error`:
      1. Drain batch
      2. If non-empty: call transport.sendBatch directly (synchronous)
      3. Return error if send fails
    - `Close() error`:
      1. Cancel background context (stops flushLoop)
      2. Wait for doneCh (flushLoop exited)
      3. Call Flush() for any remaining events
      4. Return error if final flush fails
  </action>
  <verify>
    - `cd sdk/go && go build ./...` compiles
    - `cd sdk/go && go vet ./...` passes
    - `grep "uuid.New" sdk/go/causality.go` confirms idempotency key generation
    - `grep "Track\|Flush\|Close" sdk/go/causality.go` confirms public API
    - `grep "flushLoop" sdk/go/batch.go` confirms background flush
  </verify>
  <done>
    Go SDK client provides Track (async enqueue), Flush (sync send), and Close (flush + shutdown). Each event gets a UUID idempotency key. Server context auto-collected. Batch flush on size or interval with background goroutine.
  </done>
</task>

</tasks>

<verification>
- `cd sdk/go && go build ./...` compiles
- `cd sdk/go && go vet ./...` passes
- SDK has separate go.mod with correct module path
- Client has Track, Flush, Close public methods
- Transport sends to /v1/events/batch with X-API-Key header and Content-Type: application/json
- Retry with exponential backoff on 5xx
- Idempotency key (UUID) set on every Track call
- Server context collected (hostname, Go version, SDK version)
- SDK JSON field names verified to match server's expected protojson format (snake_case)
- Server content-type handling verified: JSON accepted at /v1/events/batch endpoint
</verification>

<success_criteria>
- Go module at github.com/SebastienMelki/causality/sdk/go compiles independently
- Track(event) is non-blocking, enqueues for async send
- Flush() synchronously sends all queued events
- Close() flushes and shuts down the background goroutine
- Configurable batch size (default: 50) and flush interval (default: 30s)
- Retry with exponential backoff (max 3 retries)
- Idempotency key (UUID) set on each event
- Server context (hostname, Go version, SDK version) attached to events
- Minimal dependencies (uuid only, no protobuf dependency)
</success_criteria>

<output>
After completion, create `.planning/phases/01-pipeline-hardening-observability-go-sdk/01-09-SUMMARY.md`
</output>
