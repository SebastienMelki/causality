---
phase: 01-pipeline-hardening-observability-go-sdk
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - internal/auth/module.go
  - internal/auth/ports.go
  - internal/auth/adapters.go
  - internal/auth/internal/domain/apikey.go
  - internal/auth/internal/service/key_service.go
  - internal/auth/internal/repo/key_repo.go
  - internal/auth/internal/handler/key_handler.go
  - internal/auth/migrations/001_create_api_keys.up.sql
  - internal/auth/migrations/001_create_api_keys.down.sql
autonomous: true

must_haves:
  truths:
    - "API keys are generated as 64-char hex strings with SHA256 hash stored in PostgreSQL"
    - "Key validation uses SHA256 hash + constant-time comparison"
    - "Keys are tied to an app_id and can be created, revoked, and listed"
    - "Auth middleware returns 401 for missing/invalid X-API-Key header"
    - "Auth middleware skips /health, /ready, /metrics endpoints"
    - "Valid key injects app_id into request context"
  artifacts:
    - path: "internal/auth/module.go"
      provides: "Auth module facade with New(), middleware accessor"
      exports: ["Module", "New"]
    - path: "internal/auth/ports.go"
      provides: "KeyStore and KeyValidator interfaces"
      contains: "KeyStore"
    - path: "internal/auth/adapters.go"
      provides: "AuthMiddleware HTTP middleware"
      exports: ["AuthMiddleware"]
    - path: "internal/auth/internal/domain/apikey.go"
      provides: "APIKey domain type, GenerateKey, HashKey functions"
      contains: "GenerateKey"
    - path: "internal/auth/internal/service/key_service.go"
      provides: "Key validation, creation, revocation business logic"
      contains: "ValidateKey"
    - path: "internal/auth/internal/repo/key_repo.go"
      provides: "PostgreSQL key storage"
      contains: "key_hash"
    - path: "internal/auth/internal/handler/key_handler.go"
      provides: "Admin HTTP handlers for key CRUD (create, revoke, list)"
      exports: ["KeyHandler"]
    - path: "internal/auth/migrations/001_create_api_keys.up.sql"
      provides: "api_keys table DDL"
      contains: "CREATE TABLE"
  key_links:
    - from: "internal/auth/adapters.go"
      to: "internal/auth/internal/service/key_service.go"
      via: "middleware calls service.ValidateKey"
      pattern: "ValidateKey"
    - from: "internal/auth/internal/service/key_service.go"
      to: "internal/auth/internal/repo/key_repo.go"
      via: "service calls repo.FindByHash"
      pattern: "FindByHash"
    - from: "internal/auth/internal/domain/apikey.go"
      to: "crypto/sha256"
      via: "HashKey uses SHA256 not bcrypt"
      pattern: "sha256\\.Sum256"
    - from: "internal/auth/internal/handler/key_handler.go"
      to: "internal/auth/internal/service/key_service.go"
      via: "handler calls service.CreateKey/RevokeKey/ListKeys"
      pattern: "CreateKey|RevokeKey|ListKeys"
---

<objective>
Create the auth module following the hexagonal pattern: domain types (APIKey, hashing), service (create/validate/revoke keys), PostgreSQL repository, SQL migrations, and HTTP auth middleware.

Purpose: API key authentication is required by R1.4 and blocks the gateway integration plan (rate limiting per key, SDK auth). This module provides the complete auth vertical slice.
Output: `internal/auth/` module with domain, service, repo, migrations, and middleware adapter.
</objective>

<execution_context>
@/Users/sebastienmelki/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sebastienmelki/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-pipeline-hardening-observability-go-sdk/01-RESEARCH.md
@.planning/REQUIREMENTS.md
@internal/gateway/middleware.go
@internal/reaction/db/client.go
@go.mod
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create auth domain, service, and repository</name>
  <files>
    internal/auth/internal/domain/apikey.go
    internal/auth/internal/service/key_service.go
    internal/auth/internal/repo/key_repo.go
    internal/auth/ports.go
    internal/auth/migrations/001_create_api_keys.up.sql
    internal/auth/migrations/001_create_api_keys.down.sql
  </files>
  <action>
    **Create `internal/auth/ports.go`:**
    - `KeyStore` interface:
      ```go
      type KeyStore interface {
          FindByHash(ctx context.Context, keyHash string) (*domain.APIKey, error)
          Create(ctx context.Context, key *domain.APIKey) error
          Revoke(ctx context.Context, id string) error
          ListByAppID(ctx context.Context, appID string) ([]domain.APIKey, error)
      }
      ```
    - `AppIDContextKey` type and constant for context injection

    **Create `internal/auth/internal/domain/apikey.go`:**
    - `APIKey` struct: ID (string/UUID), AppID, KeyHash, Name, Revoked (bool), CreatedAt, RevokedAt (*time.Time)
    - `GenerateKey() (plaintext string, hash string, err error)` — generates 32 random bytes, hex-encodes to 64-char string, returns plaintext + SHA256 hash
    - `HashKey(plaintext string) string` — SHA256 hash of plaintext, hex-encoded
    - `ValidateKeyFormat(key string) bool` — checks key is 64 hex chars
    - Use `crypto/rand` for generation, `crypto/sha256` for hashing, `encoding/hex` for encoding
    - Do NOT use bcrypt — API keys are high-entropy random strings, SHA256 is sufficient and fast (see research pitfall #6)

    **Create `internal/auth/internal/service/key_service.go`:**
    - `KeyService` struct with `store KeyStore` (interface from ports.go), `logger *slog.Logger`
    - `NewKeyService(store KeyStore, logger *slog.Logger) *KeyService`
    - `ValidateKey(ctx context.Context, keyHash string) (*domain.APIKey, error)` — calls `store.FindByHash`, returns nil if not found or revoked
    - `CreateKey(ctx context.Context, appID, name string) (plaintext string, key *domain.APIKey, error)` — calls `domain.GenerateKey()`, creates APIKey, calls `store.Create`, returns plaintext (shown once to user)
    - `RevokeKey(ctx context.Context, id string) error` — calls `store.Revoke`
    - `ListKeys(ctx context.Context, appID string) ([]domain.APIKey, error)` — calls `store.ListByAppID`

    **Create `internal/auth/internal/repo/key_repo.go`:**
    - `KeyRepository` struct with `*sql.DB`
    - `NewKeyRepository(db *sql.DB) *KeyRepository`
    - Implement all `KeyStore` interface methods using PostgreSQL queries
    - `FindByHash`: `SELECT id, app_id, key_hash, name, revoked, created_at, revoked_at FROM api_keys WHERE key_hash = $1 AND NOT revoked`
    - `Create`: `INSERT INTO api_keys (id, app_id, key_hash, name) VALUES ($1, $2, $3, $4)`
    - `Revoke`: `UPDATE api_keys SET revoked = true, revoked_at = now() WHERE id = $1`
    - `ListByAppID`: `SELECT ... FROM api_keys WHERE app_id = $1 ORDER BY created_at DESC`
    - Use `github.com/google/uuid` for generating IDs
    - Use `github.com/lib/pq` (already in go.mod) for PostgreSQL

    **Create SQL migrations:**
    - `001_create_api_keys.up.sql`:
      ```sql
      CREATE TABLE IF NOT EXISTS api_keys (
          id         UUID PRIMARY KEY DEFAULT gen_random_uuid(),
          app_id     TEXT NOT NULL,
          key_hash   TEXT NOT NULL UNIQUE,
          name       TEXT NOT NULL DEFAULT '',
          revoked    BOOLEAN NOT NULL DEFAULT false,
          created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
          revoked_at TIMESTAMPTZ
      );
      CREATE INDEX idx_api_keys_key_hash ON api_keys(key_hash) WHERE NOT revoked;
      CREATE INDEX idx_api_keys_app_id ON api_keys(app_id);
      ```
    - `001_create_api_keys.down.sql`:
      ```sql
      DROP TABLE IF EXISTS api_keys;
      ```
  </action>
  <verify>
    - `go build ./internal/auth/...` compiles
    - `go vet ./internal/auth/...` passes
    - Verify domain.GenerateKey returns a 64-char hex string
    - Verify domain.HashKey uses SHA256 (grep for sha256 in apikey.go)
  </verify>
  <done>
    Auth domain, service, and repository exist. SQL migration creates api_keys table. Key generation uses SHA256 hashing. Service provides create/validate/revoke/list operations through the KeyStore port.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create auth module facade and HTTP middleware adapter</name>
  <files>
    internal/auth/module.go
    internal/auth/adapters.go
  </files>
  <action>
    **Create `internal/auth/module.go`:**
    - `Module` struct holding `*service.KeyService` and `*repo.KeyRepository`
    - `New(db *sql.DB, logger *slog.Logger) *Module` — creates repo, creates service, returns module
    - `CreateKey(ctx context.Context, appID, name string) (string, error)` — delegates to service, returns plaintext key
    - `RevokeKey(ctx context.Context, id string) error` — delegates to service
    - `ListKeys(ctx context.Context, appID string) ([]domain.APIKey, error)` — delegates to service
    - Expose `AuthMiddleware()` method that returns the middleware (delegates to adapters.go)

    **Create `internal/auth/adapters.go`:**
    - `AuthMiddleware() func(http.Handler) http.Handler` method on Module
    - Middleware logic:
      1. Skip auth for paths: `/health`, `/ready`, `/metrics` — call `next.ServeHTTP` directly
      2. Read `X-API-Key` header. If empty: return 401 JSON `{"error":"missing API key"}`
      3. Hash the key using `domain.HashKey(apiKey)`
      4. Call `m.service.ValidateKey(ctx, keyHash)`
      5. If nil or error: return 401 JSON `{"error":"invalid API key"}`
      6. Inject `key.AppID` into context using `context.WithValue(r.Context(), AppIDContextKey, key.AppID)`
      7. Call `next.ServeHTTP(w, r.WithContext(ctx))`
    - Use `crypto/subtle.ConstantTimeCompare` is NOT needed here — we compare hashes via database lookup, not in-memory comparison. The SHA256 hash lookup in PostgreSQL is sufficient.
    - Helper: `GetAppID(ctx context.Context) string` — extracts app_id from context

    Follow the existing middleware pattern in `internal/gateway/middleware.go` (function returning `func(http.Handler) http.Handler`).

    **Update `internal/auth/module.go`** to expose a `RegisterAdminRoutes(mux *http.ServeMux)` method that mounts the key handler routes.
  </action>
  <verify>
    - `go build ./internal/auth/...` compiles
    - `go vet ./internal/auth/...` passes
    - Verify AuthMiddleware skips health endpoints (grep for "/health" in adapters.go)
    - Verify 401 is returned for missing key (grep for StatusUnauthorized in adapters.go)
  </verify>
  <done>
    Auth module has a clean facade (Module struct) and HTTP middleware adapter. Middleware validates X-API-Key header, looks up hashed key in database, injects app_id into context, and skips auth for health/metrics endpoints.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create admin API key management HTTP endpoints</name>
  <files>
    internal/auth/internal/handler/key_handler.go
    internal/auth/module.go
  </files>
  <action>
    **Create `internal/auth/internal/handler/key_handler.go`:**
    R1.4 requires admin API endpoints for key management (create, revoke, list). These are the admin-facing CRUD endpoints — no UI yet, just HTTP JSON API.

    - `KeyHandler` struct with `service *service.KeyService`, `logger *slog.Logger`
    - `NewKeyHandler(svc *service.KeyService, logger *slog.Logger) *KeyHandler`

    - `POST /api/admin/keys` — Create a new API key:
      - Request body: `{"app_id": "string", "name": "string"}`
      - Validates app_id is non-empty
      - Calls `service.CreateKey(ctx, appID, name)`
      - Returns 201 with `{"id": "uuid", "app_id": "...", "api_key": "plaintext...", "name": "...", "created_at": "..."}`
      - **Important:** The plaintext API key is returned ONLY in this response. It is never stored or retrievable again. Response must include a warning/note about this.

    - `DELETE /api/admin/keys/{id}` — Revoke an API key:
      - Path parameter: key ID (UUID)
      - Calls `service.RevokeKey(ctx, id)`
      - Returns 204 No Content on success
      - Returns 404 if key not found

    - `GET /api/admin/keys?app_id={app_id}` — List API keys for an app:
      - Query parameter: app_id (required)
      - Calls `service.ListKeys(ctx, appID)`
      - Returns 200 with `{"keys": [{"id": "...", "app_id": "...", "name": "...", "revoked": false, "created_at": "..."}]}`
      - **Never** returns key hashes or plaintext keys in list response

    - `Routes() http.Handler` method that returns a `http.ServeMux` with all three routes mounted:
      ```go
      func (h *KeyHandler) Routes() http.Handler {
          mux := http.NewServeMux()
          mux.HandleFunc("POST /api/admin/keys", h.CreateKey)
          mux.HandleFunc("DELETE /api/admin/keys/{id}", h.RevokeKey)
          mux.HandleFunc("GET /api/admin/keys", h.ListKeys)
          return mux
      }
      ```

    - All handlers return JSON responses with appropriate Content-Type header
    - All handlers return descriptive JSON error responses: `{"error": "message"}`

    **Update `internal/auth/module.go`:**
    - Add `handler *handler.KeyHandler` field to Module struct
    - In `New()`: create the key handler `handler.NewKeyHandler(svc, logger)`
    - Add `RegisterAdminRoutes(mux *http.ServeMux)` method:
      ```go
      func (m *Module) RegisterAdminRoutes(mux *http.ServeMux) {
          routes := m.handler.Routes()
          mux.Handle("/api/admin/keys", routes)
          mux.Handle("/api/admin/keys/", routes)
      }
      ```
    - This allows the gateway server to mount admin routes by calling `authMod.RegisterAdminRoutes(mux)` in server setup

    **Note:** These admin endpoints are NOT protected by the API key auth middleware (they manage keys, not consume them). In Phase 3 (R3.2/R3.3), these will be protected by session auth + RBAC (admin role only). For now in Phase 1, they are unprotected — acceptable for local Docker Compose development. Add a TODO comment noting that session auth must be added in Phase 3.
  </action>
  <verify>
    - `go build ./internal/auth/...` compiles
    - `go vet ./internal/auth/...` passes
    - `grep "POST /api/admin/keys" internal/auth/internal/handler/key_handler.go` shows create endpoint
    - `grep "DELETE /api/admin/keys" internal/auth/internal/handler/key_handler.go` shows revoke endpoint
    - `grep "GET /api/admin/keys" internal/auth/internal/handler/key_handler.go` shows list endpoint
    - `grep "RegisterAdminRoutes" internal/auth/module.go` shows route registration method
  </verify>
  <done>
    Admin API key management endpoints exist at /api/admin/keys (POST create, DELETE revoke, GET list). Create returns plaintext key once. List never exposes key hashes. Module facade exposes RegisterAdminRoutes for gateway wiring. R1.4 "Key management: create, revoke, list (admin API, no UI yet)" fully covered.
  </done>
</task>

</tasks>

<verification>
- `go build ./internal/auth/...` compiles
- All files exist: module.go, ports.go, adapters.go, internal/domain/apikey.go, internal/service/key_service.go, internal/repo/key_repo.go, internal/handler/key_handler.go
- Migration SQL files exist in internal/auth/migrations/
- `grep "sha256" internal/auth/internal/domain/apikey.go` confirms SHA256 usage
- `grep "StatusUnauthorized" internal/auth/adapters.go` confirms 401 responses
- `grep "POST /api/admin/keys" internal/auth/internal/handler/key_handler.go` confirms admin create endpoint
- `grep "DELETE /api/admin/keys" internal/auth/internal/handler/key_handler.go` confirms admin revoke endpoint
- `grep "GET /api/admin/keys" internal/auth/internal/handler/key_handler.go` confirms admin list endpoint
- No references to bcrypt in the auth module
</verification>

<success_criteria>
- Auth module follows hexagonal pattern with ports (interfaces) and adapters
- API keys generated as 64-char hex strings, stored as SHA256 hashes
- Middleware validates X-API-Key header and returns 401 for invalid/missing keys
- Middleware injects app_id into context for downstream handlers
- Health/ready/metrics endpoints are excluded from auth
- PostgreSQL migration creates api_keys table with proper indexes
- Create/revoke/list key management operations available through module facade
- Admin API endpoints: POST /api/admin/keys (create), DELETE /api/admin/keys/{id} (revoke), GET /api/admin/keys (list)
- Create endpoint returns plaintext key exactly once; list endpoint never exposes key hashes
</success_criteria>

<output>
After completion, create `.planning/phases/01-pipeline-hardening-observability-go-sdk/01-03-SUMMARY.md`
</output>
