---
phase: 01-pipeline-hardening-observability-go-sdk
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - internal/auth/module.go
  - internal/auth/ports.go
  - internal/auth/adapters.go
  - internal/auth/internal/domain/apikey.go
  - internal/auth/internal/service/key_service.go
  - internal/auth/internal/repo/key_repo.go
  - internal/auth/migrations/001_create_api_keys.up.sql
  - internal/auth/migrations/001_create_api_keys.down.sql
autonomous: true

must_haves:
  truths:
    - "API keys are generated as 64-char hex strings with SHA256 hash stored in PostgreSQL"
    - "Key validation uses SHA256 hash + constant-time comparison"
    - "Keys are tied to an app_id and can be created, revoked, and listed"
    - "Auth middleware returns 401 for missing/invalid X-API-Key header"
    - "Auth middleware skips /health, /ready, /metrics endpoints"
    - "Valid key injects app_id into request context"
  artifacts:
    - path: "internal/auth/module.go"
      provides: "Auth module facade with New(), middleware accessor"
      exports: ["Module", "New"]
    - path: "internal/auth/ports.go"
      provides: "KeyStore and KeyValidator interfaces"
      contains: "KeyStore"
    - path: "internal/auth/adapters.go"
      provides: "AuthMiddleware HTTP middleware"
      exports: ["AuthMiddleware"]
    - path: "internal/auth/internal/domain/apikey.go"
      provides: "APIKey domain type, GenerateKey, HashKey functions"
      contains: "GenerateKey"
    - path: "internal/auth/internal/service/key_service.go"
      provides: "Key validation, creation, revocation business logic"
      contains: "ValidateKey"
    - path: "internal/auth/internal/repo/key_repo.go"
      provides: "PostgreSQL key storage"
      contains: "key_hash"
    - path: "internal/auth/migrations/001_create_api_keys.up.sql"
      provides: "api_keys table DDL"
      contains: "CREATE TABLE"
  key_links:
    - from: "internal/auth/adapters.go"
      to: "internal/auth/internal/service/key_service.go"
      via: "middleware calls service.ValidateKey"
      pattern: "ValidateKey"
    - from: "internal/auth/internal/service/key_service.go"
      to: "internal/auth/internal/repo/key_repo.go"
      via: "service calls repo.FindByHash"
      pattern: "FindByHash"
    - from: "internal/auth/internal/domain/apikey.go"
      to: "crypto/sha256"
      via: "HashKey uses SHA256 not bcrypt"
      pattern: "sha256\\.Sum256"
---

<objective>
Create the auth module following the hexagonal pattern: domain types (APIKey, hashing), service (create/validate/revoke keys), PostgreSQL repository, SQL migrations, and HTTP auth middleware.

Purpose: API key authentication is required by R1.4 and blocks the gateway integration plan (rate limiting per key, SDK auth). This module provides the complete auth vertical slice.
Output: `internal/auth/` module with domain, service, repo, migrations, and middleware adapter.
</objective>

<execution_context>
@/Users/sebastienmelki/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sebastienmelki/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-pipeline-hardening-observability-go-sdk/01-RESEARCH.md
@.planning/REQUIREMENTS.md
@internal/gateway/middleware.go
@internal/reaction/db/client.go
@go.mod
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create auth domain, service, and repository</name>
  <files>
    internal/auth/internal/domain/apikey.go
    internal/auth/internal/service/key_service.go
    internal/auth/internal/repo/key_repo.go
    internal/auth/ports.go
    internal/auth/migrations/001_create_api_keys.up.sql
    internal/auth/migrations/001_create_api_keys.down.sql
  </files>
  <action>
    **Create `internal/auth/ports.go`:**
    - `KeyStore` interface:
      ```go
      type KeyStore interface {
          FindByHash(ctx context.Context, keyHash string) (*domain.APIKey, error)
          Create(ctx context.Context, key *domain.APIKey) error
          Revoke(ctx context.Context, id string) error
          ListByAppID(ctx context.Context, appID string) ([]domain.APIKey, error)
      }
      ```
    - `AppIDContextKey` type and constant for context injection

    **Create `internal/auth/internal/domain/apikey.go`:**
    - `APIKey` struct: ID (string/UUID), AppID, KeyHash, Name, Revoked (bool), CreatedAt, RevokedAt (*time.Time)
    - `GenerateKey() (plaintext string, hash string, err error)` — generates 32 random bytes, hex-encodes to 64-char string, returns plaintext + SHA256 hash
    - `HashKey(plaintext string) string` — SHA256 hash of plaintext, hex-encoded
    - `ValidateKeyFormat(key string) bool` — checks key is 64 hex chars
    - Use `crypto/rand` for generation, `crypto/sha256` for hashing, `encoding/hex` for encoding
    - Do NOT use bcrypt — API keys are high-entropy random strings, SHA256 is sufficient and fast (see research pitfall #6)

    **Create `internal/auth/internal/service/key_service.go`:**
    - `KeyService` struct with `store KeyStore` (interface from ports.go), `logger *slog.Logger`
    - `NewKeyService(store KeyStore, logger *slog.Logger) *KeyService`
    - `ValidateKey(ctx context.Context, keyHash string) (*domain.APIKey, error)` — calls `store.FindByHash`, returns nil if not found or revoked
    - `CreateKey(ctx context.Context, appID, name string) (plaintext string, key *domain.APIKey, error)` — calls `domain.GenerateKey()`, creates APIKey, calls `store.Create`, returns plaintext (shown once to user)
    - `RevokeKey(ctx context.Context, id string) error` — calls `store.Revoke`
    - `ListKeys(ctx context.Context, appID string) ([]domain.APIKey, error)` — calls `store.ListByAppID`

    **Create `internal/auth/internal/repo/key_repo.go`:**
    - `KeyRepository` struct with `*sql.DB`
    - `NewKeyRepository(db *sql.DB) *KeyRepository`
    - Implement all `KeyStore` interface methods using PostgreSQL queries
    - `FindByHash`: `SELECT id, app_id, key_hash, name, revoked, created_at, revoked_at FROM api_keys WHERE key_hash = $1 AND NOT revoked`
    - `Create`: `INSERT INTO api_keys (id, app_id, key_hash, name) VALUES ($1, $2, $3, $4)`
    - `Revoke`: `UPDATE api_keys SET revoked = true, revoked_at = now() WHERE id = $1`
    - `ListByAppID`: `SELECT ... FROM api_keys WHERE app_id = $1 ORDER BY created_at DESC`
    - Use `github.com/google/uuid` for generating IDs
    - Use `github.com/lib/pq` (already in go.mod) for PostgreSQL

    **Create SQL migrations:**
    - `001_create_api_keys.up.sql`:
      ```sql
      CREATE TABLE IF NOT EXISTS api_keys (
          id         UUID PRIMARY KEY DEFAULT gen_random_uuid(),
          app_id     TEXT NOT NULL,
          key_hash   TEXT NOT NULL UNIQUE,
          name       TEXT NOT NULL DEFAULT '',
          revoked    BOOLEAN NOT NULL DEFAULT false,
          created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
          revoked_at TIMESTAMPTZ
      );
      CREATE INDEX idx_api_keys_key_hash ON api_keys(key_hash) WHERE NOT revoked;
      CREATE INDEX idx_api_keys_app_id ON api_keys(app_id);
      ```
    - `001_create_api_keys.down.sql`:
      ```sql
      DROP TABLE IF EXISTS api_keys;
      ```
  </action>
  <verify>
    - `go build ./internal/auth/...` compiles
    - `go vet ./internal/auth/...` passes
    - Verify domain.GenerateKey returns a 64-char hex string
    - Verify domain.HashKey uses SHA256 (grep for sha256 in apikey.go)
  </verify>
  <done>
    Auth domain, service, and repository exist. SQL migration creates api_keys table. Key generation uses SHA256 hashing. Service provides create/validate/revoke/list operations through the KeyStore port.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create auth module facade and HTTP middleware adapter</name>
  <files>
    internal/auth/module.go
    internal/auth/adapters.go
  </files>
  <action>
    **Create `internal/auth/module.go`:**
    - `Module` struct holding `*service.KeyService` and `*repo.KeyRepository`
    - `New(db *sql.DB, logger *slog.Logger) *Module` — creates repo, creates service, returns module
    - `CreateKey(ctx context.Context, appID, name string) (string, error)` — delegates to service, returns plaintext key
    - `RevokeKey(ctx context.Context, id string) error` — delegates to service
    - `ListKeys(ctx context.Context, appID string) ([]domain.APIKey, error)` — delegates to service
    - Expose `AuthMiddleware()` method that returns the middleware (delegates to adapters.go)

    **Create `internal/auth/adapters.go`:**
    - `AuthMiddleware() func(http.Handler) http.Handler` method on Module
    - Middleware logic:
      1. Skip auth for paths: `/health`, `/ready`, `/metrics` — call `next.ServeHTTP` directly
      2. Read `X-API-Key` header. If empty: return 401 JSON `{"error":"missing API key"}`
      3. Hash the key using `domain.HashKey(apiKey)`
      4. Call `m.service.ValidateKey(ctx, keyHash)`
      5. If nil or error: return 401 JSON `{"error":"invalid API key"}`
      6. Inject `key.AppID` into context using `context.WithValue(r.Context(), AppIDContextKey, key.AppID)`
      7. Call `next.ServeHTTP(w, r.WithContext(ctx))`
    - Use `crypto/subtle.ConstantTimeCompare` is NOT needed here — we compare hashes via database lookup, not in-memory comparison. The SHA256 hash lookup in PostgreSQL is sufficient.
    - Helper: `GetAppID(ctx context.Context) string` — extracts app_id from context

    Follow the existing middleware pattern in `internal/gateway/middleware.go` (function returning `func(http.Handler) http.Handler`).
  </action>
  <verify>
    - `go build ./internal/auth/...` compiles
    - `go vet ./internal/auth/...` passes
    - Verify AuthMiddleware skips health endpoints (grep for "/health" in adapters.go)
    - Verify 401 is returned for missing key (grep for StatusUnauthorized in adapters.go)
  </verify>
  <done>
    Auth module has a clean facade (Module struct) and HTTP middleware adapter. Middleware validates X-API-Key header, looks up hashed key in database, injects app_id into context, and skips auth for health/metrics endpoints.
  </done>
</task>

</tasks>

<verification>
- `go build ./internal/auth/...` compiles
- All files exist: module.go, ports.go, adapters.go, internal/domain/apikey.go, internal/service/key_service.go, internal/repo/key_repo.go
- Migration SQL files exist in internal/auth/migrations/
- `grep "sha256" internal/auth/internal/domain/apikey.go` confirms SHA256 usage
- `grep "StatusUnauthorized" internal/auth/adapters.go` confirms 401 responses
- No references to bcrypt in the auth module
</verification>

<success_criteria>
- Auth module follows hexagonal pattern with ports (interfaces) and adapters
- API keys generated as 64-char hex strings, stored as SHA256 hashes
- Middleware validates X-API-Key header and returns 401 for invalid/missing keys
- Middleware injects app_id into context for downstream handlers
- Health/ready/metrics endpoints are excluded from auth
- PostgreSQL migration creates api_keys table with proper indexes
- Create/revoke/list key management operations available through module facade
</success_criteria>

<output>
After completion, create `.planning/phases/01-pipeline-hardening-observability-go-sdk/01-03-SUMMARY.md`
</output>
