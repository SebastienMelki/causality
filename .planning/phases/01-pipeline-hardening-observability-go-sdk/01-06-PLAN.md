---
phase: 01-pipeline-hardening-observability-go-sdk
plan: 06
type: execute
wave: 3
depends_on: ["01-01", "01-03", "01-04"]
files_modified:
  - internal/gateway/server.go
  - internal/gateway/middleware.go
  - internal/gateway/service.go
  - internal/gateway/config.go
  - cmd/server/main.go
  - docker-compose.yml
autonomous: true

must_haves:
  truths:
    - "Unauthenticated /v1/events/ingest returns 401"
    - "Per-API-key rate limiting enforced (default: 1000 events/sec)"
    - "Request body size limited (default: 5 MB)"
    - "Events without app_id, event_type, or timestamp return 400"
    - "Prometheus metrics at /metrics on HTTP server"
    - "Duplicate events (same idempotency_key) silently dropped"
    - "Server enriches events with idempotency_key if not provided"
  artifacts:
    - path: "internal/gateway/server.go"
      provides: "Updated server with auth, dedup, metrics middleware"
      contains: "AuthMiddleware"
    - path: "internal/gateway/middleware.go"
      provides: "Per-key rate limiter and body size limiter"
      contains: "PerKeyRateLimit"
    - path: "internal/gateway/service.go"
      provides: "Event validation and dedup check"
      contains: "idempotency_key"
    - path: "cmd/server/main.go"
      provides: "Wired auth, dedup, observability modules"
      contains: "auth.New"
  key_links:
    - from: "internal/gateway/server.go"
      to: "internal/auth/adapters.go"
      via: "mounts AuthMiddleware in middleware chain"
      pattern: "AuthMiddleware"
    - from: "internal/gateway/middleware.go"
      to: "auth.GetAppID"
      via: "per-key rate limiter reads app_id from auth context"
      pattern: "GetAppID"
    - from: "internal/gateway/service.go"
      to: "internal/dedup/module.go"
      via: "calls dedup.IsDuplicate before publishing"
      pattern: "IsDuplicate"
    - from: "cmd/server/main.go"
      to: "internal/auth/module.go"
      via: "creates auth module, passes to server"
      pattern: "auth\\.New"
---

<objective>
Integrate auth middleware, per-key rate limiting, body size limits, event validation, dedup check, and observability into the HTTP gateway server.

Purpose: This plan wires together the foundation (01-01 observability), auth (01-03), and dedup (01-04) modules into the existing gateway. It also adds the remaining R1.8 requirements (rate limiting, validation, body size).
Output: Fully secured, validated, rate-limited, and observable HTTP gateway.
</objective>

<execution_context>
@/Users/sebastienmelki/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sebastienmelki/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-pipeline-hardening-observability-go-sdk/01-RESEARCH.md
@.planning/phases/01-pipeline-hardening-observability-go-sdk/01-01-SUMMARY.md
@.planning/phases/01-pipeline-hardening-observability-go-sdk/01-03-SUMMARY.md
@.planning/phases/01-pipeline-hardening-observability-go-sdk/01-04-SUMMARY.md
@internal/gateway/server.go
@internal/gateway/middleware.go
@internal/gateway/service.go
@internal/gateway/config.go
@cmd/server/main.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add per-key rate limiting, body size limit, and event validation middleware</name>
  <files>
    internal/gateway/middleware.go
    internal/gateway/service.go
    internal/gateway/config.go
  </files>
  <action>
    **Update `internal/gateway/config.go`:**
    - Add to `RateLimitConfig`: `PerKeyRPS float64` (env: `RATE_LIMIT_PER_KEY_RPS`, default: 1000) and `PerKeyBurst int` (env: `RATE_LIMIT_PER_KEY_BURST`, default: 2000)
    - Add `MaxBodySize int64` (env: `MAX_BODY_SIZE`, default: 5*1024*1024 — 5 MB) to gateway Config
    - Add `MaxBatchEvents int` (env: `MAX_BATCH_EVENTS`, default: 1000) to gateway Config

    **Update `internal/gateway/middleware.go`:**
    - Replace the existing `RateLimit` middleware with `PerKeyRateLimit`:
      ```go
      func PerKeyRateLimit(cfg RateLimitConfig) Middleware {
          if !cfg.Enabled {
              return func(next http.Handler) http.Handler { return next }
          }
          limiters := &sync.Map{} // map[string]*rate.Limiter
          // Periodic cleanup goroutine: every 5 minutes, delete limiters
          // not seen in last 10 minutes (use a separate lastSeen map)
          return func(next http.Handler) http.Handler {
              return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
                  appID := auth.GetAppID(r.Context())
                  if appID == "" {
                      // No app_id = no rate limiting (auth middleware hasn't run or endpoint is unauthenticated)
                      next.ServeHTTP(w, r)
                      return
                  }
                  v, _ := limiters.LoadOrStore(appID, rate.NewLimiter(rate.Limit(cfg.PerKeyRPS), cfg.PerKeyBurst))
                  limiter := v.(*rate.Limiter)
                  if !limiter.Allow() {
                      http.Error(w, `{"error":"rate limit exceeded"}`, http.StatusTooManyRequests)
                      return
                  }
                  next.ServeHTTP(w, r)
              })
          }
      }
      ```
    - Add `BodySizeLimit(maxBytes int64) Middleware`:
      ```go
      func BodySizeLimit(maxBytes int64) Middleware {
          return func(next http.Handler) http.Handler {
              return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
                  r.Body = http.MaxBytesReader(w, r.Body, maxBytes)
                  next.ServeHTTP(w, r)
              })
          }
      }
      ```
    - Keep the old `RateLimit` function but mark it deprecated (backward compat during transition)

    **Update `internal/gateway/service.go`:**
    - Add `dedup` field to `EventService` struct (type: interface with `IsDuplicate(key string) bool` method, or concrete dedup module reference)
    - Update `NewEventService` to accept a dedup checker (can be nil for backward compat)
    - In `enrichEnvelope`: if `event.IdempotencyKey` is empty, generate a UUID and set it (server-side fallback for SDKs that don't set it yet)
    - In `IngestEvent`: after enrich, before publish, check `dedup.IsDuplicate(event.IdempotencyKey)`. If duplicate: return success response (silently drop), do not publish to NATS
    - In `IngestEventBatch`: same dedup check per event
    - Add validation in `IngestEvent` and `IngestEventBatch`:
      - `event.AppId` must not be empty → return 400 "app_id is required"
      - `event.EventType` must not be empty → return 400 "event_type is required"
      - `event.TimestampMs` must be > 0 → return 400 "timestamp is required" (or set server-side if zero, which enrichEnvelope already does)
    - For batch: validate each event, mark invalid ones as rejected in results, continue with valid events
  </action>
  <verify>
    - `go build ./internal/gateway/...` compiles
    - `grep "PerKeyRateLimit" internal/gateway/middleware.go` shows per-key rate limiter
    - `grep "MaxBytesReader" internal/gateway/middleware.go` shows body size limiter
    - `grep "IsDuplicate" internal/gateway/service.go` shows dedup check
    - `grep "app_id is required" internal/gateway/service.go` shows validation
  </verify>
  <done>
    Gateway has per-key rate limiting, body size limits, event validation (required fields), and dedup integration. Rate limiter uses sync.Map with periodic cleanup. Validation returns 400 with descriptive errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire auth, dedup, observability, and new middleware into server and main</name>
  <files>
    internal/gateway/server.go
    cmd/server/main.go
    docker-compose.yml
  </files>
  <action>
    **Update `internal/gateway/server.go`:**
    - Update `NewServer` signature to accept additional dependencies: `authMiddleware func(http.Handler) http.Handler`, `obsMetrics *observability.Metrics`, `metricsHandler http.Handler`
    - Add `/metrics` endpoint: `mux.Handle("GET /metrics", metricsHandler)`
    - Update middleware chain to include auth and new middleware (order matters):
      ```go
      handler := Chain(mux,
          RequestID,
          Logging(server.logger),
          Recovery(server.logger),
          observability.HTTPMetrics(obsMetrics),     // NEW: metrics
          CORS(server.config.CORS),
          BodySizeLimit(server.config.MaxBodySize),   // NEW: body size
          authMiddleware,                              // NEW: auth (after RequestID, before rate limit)
          PerKeyRateLimit(server.config.RateLimit),   // UPDATED: per-key
          ContentType,
      )
      ```
    - Auth middleware comes before rate limiting so rate limits are per authenticated key

    **Update `cmd/server/main.go`:**
    - Import: `internal/observability`, `internal/auth`, `internal/dedup`
    - After logger setup: create observability module `obs, err := observability.New("causality-server")`
    - Defer `obs.Shutdown(ctx)`
    - Create metrics: `metrics, err := observability.NewMetrics(obs.Meter())`
    - Connect to PostgreSQL (add database config to Config struct, similar to reaction-engine main.go pattern):
      - `DATABASE_HOST`, `DATABASE_PORT`, `DATABASE_USER`, `DATABASE_PASSWORD`, `DATABASE_NAME`, `DATABASE_SSL_MODE`
      - Use `database/sql` + `lib/pq` to open connection
    - Create auth module: `authMod := auth.New(db, logger)`
    - Create dedup module: `dedupMod := dedup.New(dedupCfg, metrics, logger)`, then `dedupMod.Start(ctx)`
    - Pass dedup module to EventService (via NewEventService or server)
    - Pass auth middleware, metrics, and metrics handler to NewServer
    - On shutdown: `dedupMod.Stop()`
    - Add dedup and database config to Config struct

    **Update `docker-compose.yml`:**
    - Add PostgreSQL dependency to `causality-server`:
      ```yaml
      depends_on:
        nats:
          condition: service_healthy
        postgres:
          condition: service_healthy
      ```
    - Add database environment variables to `causality-server`:
      ```yaml
      DATABASE_HOST: "postgres"
      DATABASE_PORT: "5432"
      DATABASE_USER: "hive"
      DATABASE_PASSWORD: "hive"
      DATABASE_NAME: "causality"
      DATABASE_SSL_MODE: "disable"
      ```
    - Add new environment variables:
      ```yaml
      DEDUP_WINDOW: "10m"
      MAX_BODY_SIZE: "5242880"
      RATE_LIMIT_ENABLED: "true"
      RATE_LIMIT_PER_KEY_RPS: "1000"
      ```
    - Note: Need to add a causality database to postgres init script, or create it dynamically. Check if `docker/postgres/` has init scripts that can be extended. If the reaction engine uses its own database (`reaction_engine`), create a separate `causality` database for the server's auth tables, or reuse the same PostgreSQL instance with a different database name.
  </action>
  <verify>
    - `go build ./cmd/server/...` compiles
    - `grep "AuthMiddleware\|authMiddleware" internal/gateway/server.go` shows auth wired in
    - `grep "/metrics" internal/gateway/server.go` shows metrics endpoint
    - `grep "PerKeyRateLimit" internal/gateway/server.go` shows per-key rate limiting wired in
    - `grep "DATABASE_HOST" docker-compose.yml` shows database config for causality-server
  </verify>
  <done>
    HTTP server has auth middleware, per-key rate limiting, body size limits, dedup, event validation, and Prometheus metrics all wired together. Main creates and wires all modules. Docker Compose updated with necessary config.
  </done>
</task>

</tasks>

<verification>
- `go build ./cmd/server/...` compiles
- Auth middleware is in the middleware chain
- /metrics endpoint registered
- Per-key rate limiting replaces global rate limiting
- Body size limit middleware added
- Event validation checks app_id, event_type
- Dedup check happens before NATS publish
- Docker Compose has database config for server
</verification>

<success_criteria>
- Unauthenticated requests to /v1/events/ingest return 401
- Valid X-API-Key header passes auth and injects app_id into context
- Per-key rate limiting (1000 rps default) enforced
- Request body > 5MB rejected
- Events missing required fields (app_id, event_type) return 400
- Duplicate events (same idempotency_key) silently dropped
- Prometheus metrics at /metrics
- All modules properly wired in main.go and shut down gracefully
</success_criteria>

<output>
After completion, create `.planning/phases/01-pipeline-hardening-observability-go-sdk/01-06-SUMMARY.md`
</output>
