---
phase: 01-pipeline-hardening-observability-go-sdk
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/observability/module.go
  - internal/observability/metrics.go
  - internal/observability/middleware.go
  - proto/causality/events.proto
  - pkg/proto/causality/v1/events.pb.go
  - go.mod
  - go.sum
autonomous: true

must_haves:
  truths:
    - "OTel MeterProvider configured with Prometheus exporter"
    - "/metrics endpoint serves Prometheus exposition format"
    - "HTTP request metrics (count, latency histogram, error rate) recorded"
    - "EventEnvelope proto has idempotency_key string field"
  artifacts:
    - path: "internal/observability/module.go"
      provides: "OTel MeterProvider setup and lifecycle"
      exports: ["Module", "New", "Shutdown"]
    - path: "internal/observability/metrics.go"
      provides: "Metric instrument definitions (counters, histograms)"
      contains: "HTTPRequestDuration"
    - path: "internal/observability/middleware.go"
      provides: "HTTP middleware that records request metrics"
      exports: ["HTTPMetrics"]
    - path: "proto/causality/events.proto"
      provides: "idempotency_key field on EventEnvelope"
      contains: "idempotency_key"
  key_links:
    - from: "internal/observability/module.go"
      to: "go.opentelemetry.io/otel/exporters/prometheus"
      via: "prometheus.New() exporter"
      pattern: "prometheus\\.New"
    - from: "internal/observability/middleware.go"
      to: "internal/observability/metrics.go"
      via: "uses metric instruments"
      pattern: "HTTPRequestDuration"
---

<objective>
Set up the observability foundation (OTel + Prometheus metrics) and add the idempotency_key field to the EventEnvelope proto. These are foundational changes that all subsequent plans depend on.

Purpose: Every other plan in this phase needs metrics instrumentation and/or the idempotency key field. Building these first unblocks all parallel work.
Output: `internal/observability/` module with MeterProvider + Prometheus exporter + HTTP middleware, and updated proto with `idempotency_key` field.
</objective>

<execution_context>
@/Users/sebastienmelki/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sebastienmelki/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-pipeline-hardening-observability-go-sdk/01-RESEARCH.md
@.planning/REQUIREMENTS.md
@internal/gateway/middleware.go
@internal/gateway/server.go
@proto/causality/events.proto
@go.mod
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create observability module with OTel Prometheus metrics</name>
  <files>
    internal/observability/module.go
    internal/observability/metrics.go
    internal/observability/middleware.go
    go.mod
    go.sum
  </files>
  <action>
    Install new dependencies:
    ```
    go get go.opentelemetry.io/otel@latest
    go get go.opentelemetry.io/otel/sdk/metric@latest
    go get go.opentelemetry.io/otel/exporters/prometheus@latest
    go get github.com/prometheus/client_golang/prometheus/promhttp@latest
    ```

    Create `internal/observability/module.go`:
    - `Module` struct holding `*sdkmetric.MeterProvider` and `otel.Meter`
    - `New(serviceName string) (*Module, error)` — creates Prometheus exporter via `prometheus.New()`, creates `MeterProvider` with the reader, sets global `otel.SetMeterProvider(provider)`, returns Module
    - `Shutdown(ctx context.Context) error` — calls `provider.Shutdown(ctx)`
    - `MetricsHandler() http.Handler` — returns `promhttp.Handler()` for mounting at `/metrics`
    - `Meter() otel.Meter` — returns the meter for creating instruments

    Create `internal/observability/metrics.go`:
    - Define metric instrument types used across all services:
      - `HTTPRequestDuration` — Float64Histogram (unit: "ms", description: "HTTP request duration")
      - `HTTPRequestTotal` — Int64Counter (description: "Total HTTP requests")
      - `HTTPRequestErrors` — Int64Counter (description: "HTTP request errors (4xx, 5xx)")
      - `NATSMessagesProcessed` — Int64Counter (description: "NATS messages processed")
      - `NATSBatchSize` — Int64Histogram (description: "NATS batch sizes")
      - `NATSFlushLatency` — Float64Histogram (unit: "ms", description: "Batch flush latency")
      - `NATSAckLatency` — Float64Histogram (unit: "ms", description: "NATS ACK latency")
      - `S3FilesWritten` — Int64Counter (description: "S3 files written")
      - `S3FileSize` — Int64Histogram (unit: "bytes", description: "S3 file sizes")
      - `DedupDropped` — Int64Counter (description: "Deduplicated events dropped")
      - `DLQDepth` — Int64UpDownCounter (description: "DLQ message depth")
      - `RulesEvaluated` — Int64Counter (description: "Rules evaluated")
      - `AlertsFired` — Int64Counter (description: "Alerts fired")
      - `WebhookSuccess` — Int64Counter (description: "Webhook deliveries successful")
      - `WebhookFailure` — Int64Counter (description: "Webhook deliveries failed")
    - `Metrics` struct holding all instruments
    - `NewMetrics(meter otel.Meter) (*Metrics, error)` — creates all instruments via `meter.Float64Histogram()`, `meter.Int64Counter()`, etc.

    Create `internal/observability/middleware.go`:
    - `HTTPMetrics(metrics *Metrics) func(http.Handler) http.Handler` — HTTP middleware that:
      - Records request start time
      - Wraps ResponseWriter to capture status code
      - After handler completes: records `HTTPRequestDuration` with attributes `{method, path, status}`, increments `HTTPRequestTotal`, increments `HTTPRequestErrors` if status >= 400
      - Uses `attribute.String("method", r.Method)`, `attribute.String("path", r.URL.Path)`, `attribute.Int("status", statusCode)`

    Follow the same pattern as existing middleware in `internal/gateway/middleware.go` (function returning `func(http.Handler) http.Handler`).
  </action>
  <verify>
    - `go build ./internal/observability/...` compiles without errors
    - `go vet ./internal/observability/...` passes
  </verify>
  <done>
    Observability module exists with MeterProvider, Prometheus exporter, metric definitions, and HTTP middleware. Dependencies added to go.mod.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add idempotency_key field to EventEnvelope proto and regenerate</name>
  <files>
    proto/causality/events.proto
    pkg/proto/causality/v1/events.pb.go
  </files>
  <action>
    Edit `proto/causality/events.proto`:
    - Add `string idempotency_key = N;` field to the `EventEnvelope` message (use the next available field number). This field is set by SDKs (UUID), used for server-side deduplication.
    - Add a comment: `// SDK-generated idempotency key (UUID). Used for server-side deduplication.`

    Regenerate protobuf code:
    - Run `make buf-generate` (or `make generate`)
    - Verify the generated `pkg/proto/causality/v1/events.pb.go` contains the new `IdempotencyKey` field on `EventEnvelope`

    Do NOT modify any existing Go code to use this field yet — that happens in subsequent plans (dedup plan uses it, SDK plan sets it).
  </action>
  <verify>
    - `make buf-generate` succeeds (or equivalent proto generation command)
    - `grep -r "IdempotencyKey" pkg/proto/` returns matches in events.pb.go
    - `go build ./...` compiles successfully
  </verify>
  <done>
    EventEnvelope proto has idempotency_key string field. Generated Go code includes IdempotencyKey accessor. All existing code still compiles.
  </done>
</task>

</tasks>

<verification>
- `go build ./...` compiles the entire project
- `go vet ./...` passes
- `internal/observability/` directory exists with module.go, metrics.go, middleware.go
- `grep "idempotency_key" proto/causality/events.proto` returns the field definition
- `grep "IdempotencyKey" pkg/proto/causality/v1/events.pb.go` returns the generated field
</verification>

<success_criteria>
- OTel MeterProvider with Prometheus exporter is wired up in a reusable module
- All metric instruments for the phase are defined (HTTP, NATS, S3, dedup, DLQ, rules, webhooks)
- HTTP metrics middleware can be mounted on any HTTP mux
- EventEnvelope proto has idempotency_key field
- All existing code still compiles
</success_criteria>

<output>
After completion, create `.planning/phases/01-pipeline-hardening-observability-go-sdk/01-01-SUMMARY.md`
</output>
