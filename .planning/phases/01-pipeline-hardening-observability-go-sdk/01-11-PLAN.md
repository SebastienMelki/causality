---
phase: 01-pipeline-hardening-observability-go-sdk
plan: 11
type: execute
wave: 5
depends_on: ["01-10"]
files_modified:
  - internal/gateway/service_test.go
  - internal/warehouse/consumer_test.go
  - internal/compaction/internal/service/compaction_service_test.go
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Gateway service tests cover dedup integration (>= 70% coverage)"
    - "Warehouse consumer tests cover flush timer and shutdown (>= 70% coverage)"
    - "Compaction service tests cover partition operations (>= 70% coverage)"
  artifacts:
    - path: "internal/gateway/service_test.go"
      provides: "Gateway service tests with mock publisher integration"
      contains: "TestIngestEvent_WithDedup"
    - path: "internal/warehouse/consumer_test.go"
      provides: "Consumer tests for timer, shutdown, worker coordination"
      contains: "TestFlushTimer"
    - path: "internal/compaction/internal/service/compaction_service_test.go"
      provides: "Compaction tests with mock S3 operations"
      contains: "TestCompactPartition"
  key_links:
    - from: "internal/gateway/service_test.go"
      to: "internal/gateway/service.go"
      via: "mock publisher and dedup checker"
      pattern: "mockPublisher.*PublishEvent"
    - from: "internal/warehouse/consumer_test.go"
      to: "internal/warehouse/consumer.go"
      via: "flush timer and stop channel"
      pattern: "flushTimer|stopCh|doneCh"
    - from: "internal/compaction/internal/service/compaction_service_test.go"
      to: "internal/compaction/internal/service/compaction_service.go"
      via: "mock S3 client"
      pattern: "mockS3Client"
---

<objective>
Close test coverage gap (R1.10 blocker) by adding comprehensive unit tests for gateway service, warehouse consumer, and compaction service.

Purpose: Phase 1 requires >= 70% test coverage. While core domain modules exceed this (auth 88.9%, dedup 89.5%, SDK 95.7%), three service-level files have low coverage:
- Gateway service: 49.0% (missing dedup/publish integration tests)
- Warehouse consumer: 27.4% (missing timer/shutdown/worker tests)
- Compaction service: 17.1% (missing partition/merge tests with mocks)

Output: Updated test files with mock-based integration tests that exercise the untested code paths.
</objective>

<execution_context>
@/Users/sebastienmelki/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sebastienmelki/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-pipeline-hardening-observability-go-sdk/01-10-SUMMARY.md

# Source files being tested
@internal/gateway/service.go
@internal/warehouse/consumer.go
@internal/compaction/internal/service/compaction_service.go

# Existing tests to extend
@internal/gateway/service_test.go
@internal/warehouse/consumer_test.go
@internal/compaction/internal/service/compaction_service_test.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Gateway service integration tests</name>
  <files>internal/gateway/service_test.go</files>
  <action>
Add tests that exercise the full IngestEvent and IngestEventBatch flows with mock publisher and dedup. The existing tests use `NewEventService(nil, nil, 0, nil)` which doesn't test the publish path. Add:

1. **TestIngestEvent_WithMockPublisher_PublishesEvent**: Create service with mock publisher, verify event is published to NATS
2. **TestIngestEvent_WithDedup_FirstEventAccepted**: Verify first event passes dedup check and is published
3. **TestIngestEvent_WithDedup_DuplicateSkipsPublish**: Verify duplicate is not published but returns success
4. **TestIngestEventBatch_MixedValidInvalid**: Batch with valid + invalid events, verify partial success
5. **TestIngestEventBatch_WithDedup_FiltersDuplicates**: Batch with duplicates, verify only unique events published
6. **TestIngestEventBatch_PublishError_ReturnsRejected**: Mock publish failure for specific event, verify error result

Create a PublisherInterface and refactor mockPublisher to work with EventService:

```go
// publisherInterface abstracts the NATS publisher for testing
type publisherInterface interface {
    PublishEvent(ctx context.Context, event *pb.EventEnvelope) error
}

// Modify NewEventService to accept interface (or use internal field injection for test)
```

Since the existing EventService uses concrete `*nats.Publisher`, use reflection or add a test-only constructor that accepts the interface. Alternatively, add tests that use the concrete mock by satisfying the actual method signature.

Key coverage targets:
- Lines 77-83: publish error handling
- Lines 64-74: dedup check and silent drop
- Lines 151-165: batch publish loop
  </action>
  <verify>
```bash
cd /Users/sebastienmelki/Documents/documents_sebastiens_mac_mini/Workspace/kompani/causality && \
go test -v -cover ./internal/gateway/... 2>&1 | grep -E "(coverage|PASS|FAIL)"
```
Expect coverage >= 70% for service.go
  </verify>
  <done>Gateway service test coverage >= 70%, new tests pass, dedup and publish paths covered</done>
</task>

<task type="auto">
  <name>Task 2: Warehouse consumer timer and shutdown tests</name>
  <files>internal/warehouse/consumer_test.go</files>
  <action>
Add tests for the untested consumer paths. The existing tests cover processMessage and groupByPartition but not the timer, shutdown, or worker coordination. Add:

1. **TestFlushTimer_TriggersFlush**: Create consumer, add events to batch, verify timer triggers flush
   - Use short FlushInterval (10ms) in config
   - Add events to batch manually
   - Wait for timer to trigger
   - Verify batch is flushed (batch becomes empty)

2. **TestStop_WaitsForWorkers**: Create consumer with workers, call Stop, verify doneCh is closed
   - Use context.Background() and mock JetStream
   - Signal stop via context cancellation
   - Verify graceful shutdown completes

3. **TestStop_FinalFlush**: Verify Stop performs final flush of remaining events
   - Add events to batch
   - Call Stop
   - Verify batch is empty after Stop

4. **TestWorkerLoop_ContextCancellation**: Verify workers exit on context cancel
   - Start worker with cancelable context
   - Cancel context
   - Verify worker exits (check via channel or flag)

5. **TestProcessMessage_BatchFull_TriggersFlush**: Add events until MaxEvents reached, verify flush is called
   - Set MaxEvents to small value (e.g., 2)
   - Add 2 events
   - Verify flush was triggered (batch is empty)

6. **TestFlush_WithMetrics_RecordsLatency**: Verify metrics are recorded on flush
   - Create consumer with test metrics
   - Flush batch with events
   - Verify NATSBatchSize, S3FilesWritten, NATSFlushLatency recorded (via mock or noop meter)

Use the existing mockJetStreamMsg and create a minimal mock for the JetStream and Consumer interfaces to avoid needing real NATS.

Key coverage targets:
- Lines 196-223: flushTimer goroutine
- Lines 366-397: Stop method
- Lines 122-164: workerLoop
  </action>
  <verify>
```bash
cd /Users/sebastienmelki/Documents/documents_sebastiens_mac_mini/Workspace/kompani/causality && \
go test -v -cover ./internal/warehouse/... 2>&1 | grep -E "(coverage|PASS|FAIL)"
```
Expect coverage >= 70% for consumer.go
  </verify>
  <done>Warehouse consumer test coverage >= 70%, timer/shutdown/worker paths tested</done>
</task>

<task type="auto">
  <name>Task 3: Compaction service mock S3 tests</name>
  <files>internal/compaction/internal/service/compaction_service_test.go</files>
  <action>
Add tests for compaction operations using mock S3 client. The existing tests cover helper functions but not the main CompactAll and CompactPartition methods. Add:

1. **Create mockS3API** that implements the S3 operations used by CompactionService:
   - ListObjectsV2 (via paginator pattern)
   - GetObject
   - PutObject
   - DeleteObjects

2. **TestCompactPartition_NotEnoughFiles_ReturnsNoCompaction**: Partition with < minFiles files
   - Mock ListObjects to return 1 file
   - Call CompactPartition
   - Verify returns (false, nil)

3. **TestCompactPartition_MergesSmallFiles**: Partition with 3 small files
   - Mock ListObjects to return 3 files under targetSize
   - Mock GetObject to return valid Parquet data (use parquet-go to create)
   - Call CompactPartition
   - Verify PutObject called with compacted file
   - Verify DeleteObjects called with original files

4. **TestCompactPartition_DownloadError_ReturnsError**: S3 download fails
   - Mock GetObject to return error
   - Call CompactPartition
   - Verify error is returned

5. **TestCompactAll_ListError_ReturnsError**: ListObjects fails
   - Mock ListObjectsV2 to return error
   - Call CompactAll
   - Verify error is returned

6. **TestCompactAll_ContinuesOnPartitionError**: One partition fails, others succeed
   - Mock 2 partitions, first fails on GetObject, second succeeds
   - Call CompactAll
   - Verify it continues to second partition (no early return)

7. **TestCompactPartition_UploadError_DoesNotDeleteOriginals**: Upload fails
   - Mock PutObject to return error
   - Verify DeleteObjects is NOT called (safety rule)

For mock S3, create an interface that matches the s3.Client methods used:
```go
type s3API interface {
    ListObjectsV2(ctx context.Context, params *s3.ListObjectsV2Input, ...) (*s3.ListObjectsV2Output, error)
    GetObject(ctx context.Context, params *s3.GetObjectInput, ...) (*s3.GetObjectOutput, error)
    PutObject(ctx context.Context, params *s3.PutObjectInput, ...) (*s3.PutObjectOutput, error)
    DeleteObjects(ctx context.Context, params *s3.DeleteObjectsInput, ...) (*s3.DeleteObjectsOutput, error)
}
```

Note: The current implementation uses concrete `*s3.Client`. To test without real S3, either:
a) Create test helper Parquet files and use actual S3 interface mocking via interface extraction
b) Test the public methods through a test-specific constructor

Key coverage targets:
- Lines 90-135: CompactAll loop
- Lines 144-191: CompactPartition
- Lines 219-333: mergeBatch
- Lines 338-377: listColdPartitions
  </action>
  <verify>
```bash
cd /Users/sebastienmelki/Documents/documents_sebastiens_mac_mini/Workspace/kompani/causality && \
go test -v -cover ./internal/compaction/... 2>&1 | grep -E "(coverage|PASS|FAIL)"
```
Expect coverage >= 70% for compaction_service.go
  </verify>
  <done>Compaction service test coverage >= 70%, mock S3 operations tested, error handling verified</done>
</task>

</tasks>

<verification>
Run coverage for all three packages:

```bash
cd /Users/sebastienmelki/Documents/documents_sebastiens_mac_mini/Workspace/kompani/causality

# Gateway
go test -cover ./internal/gateway/... 2>&1 | grep "coverage"

# Warehouse
go test -cover ./internal/warehouse/... 2>&1 | grep "coverage"

# Compaction
go test -cover ./internal/compaction/... 2>&1 | grep "coverage"

# Overall Phase 1 modules
go test -cover ./internal/... ./sdk/go/... 2>&1 | grep -E "coverage|ok|FAIL"
```

All three target files should show >= 70% coverage.
</verification>

<success_criteria>
1. `go test ./internal/gateway/...` shows service.go coverage >= 70%
2. `go test ./internal/warehouse/...` shows consumer.go coverage >= 70%
3. `go test ./internal/compaction/...` shows compaction_service.go coverage >= 70%
4. All new tests pass
5. No existing tests broken
6. R1.10 (>= 70% test coverage) can now pass verification
</success_criteria>

<output>
After completion, create `.planning/phases/01-pipeline-hardening-observability-go-sdk/01-11-SUMMARY.md`
</output>
